---
title: "自制局部规划器+睿抗比赛"
date: 2026-01-15
tags: ["ROS", "机器人", "SLAM"]
---
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744358268989-987e4fad-44fd-4c86-be82-c669cdbc2dda.png)



## 第一节 整体介绍
安装仿真环境：我之前安装过，就不再安装了

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744359232655-259ad9e5-6189-4885-9cd4-ff5d195524cd.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744359394454-3d7300ca-51e5-4876-9edf-e0cf54a446b3.png)



```bash
catkin_make
source ./devel/setup.bash
roslaunch wpr_simulation wpb_gmapping.launch
rosrun wpr_simulation keyboard_vel_ctrl
建好图后按X键退出 然后保存地图
rosrun map_server map_saver -f map
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744360514225-9f0b1476-4fc6-4d76-86ec-51a2529ffca7.png)



---



载入仿真环境

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744360810061-cbcb16fd-d343-43bd-9ae9-95ad9b5c1032.png)

```bash
<!-- 载入 机器人 和 RoboCup@Home 的仿真场景 -->
  <include file="$(find wpr_simulation)/launch/wpb_stage_robocup.launch"/>
```

复制粘贴一下，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744360868800-b5e46dd0-3679-444c-938d-8418acecb332.png)

```bash
source ./devel/setup.bash
roslaunch wpr_simulation wpb_demo_nav.launch
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744361146504-540671d7-bfe0-4fe4-9785-a794a4888208.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744361178052-830fcc36-8e93-48a9-9873-51416742589a.png)

关闭掉     ![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744361279165-5ed9b983-56b0-4f1d-9baf-b37d90854a03.png)

ctrl+S保存一下，

取导航点验证一下，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744361396678-7305ed43-5cc5-4158-a26a-09712331de9a.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744361592503-b8f3c8d5-9fce-40c7-aecf-ec5491d95c7a.png)

咱们的局部规划器在Ros中是以Plugin插件形式存在的，这和通常的Node节点有些不一样，

比如这个Navigation架构图中，中间矩形框是一个节点，名称叫做move_base，而里面那些单元则是它的插件，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744361900818-9704b5f7-440f-4baa-8e22-ffb2423678a8.png)

比如这个局部规划器，咱们把它拔出来换成DWA或者TEB规划器，用的就是DWA或者TEB算法，

而这些插件的切换，是通过在move_base的节点标签里，设置相应的参数来实现，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744362197188-9e2dd480-ec6b-4df8-b54f-404435be436b.png)

可以看出来，插件Plugin其实是Node节点中可替换的一部分，更换不同的插件就能让节点宿主实现不一样的功能，这个<font style="color:#DF2A3F;">切换的过程不需要对整个节点代码进行重写和编译</font>，而只需要重写插件这一小块代码就行了，这就是ros的Plugins插件机制作用。

插件的代码比较简洁，其实就是一些回调函数的集合，连主函数都没有，非常简洁。



插件需要具备的条件：

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744363142406-326ecaef-a7d9-42d0-bfbc-0750d37b4e40.png)



第一个条件，必须血统纯正，也就是插件必须从Ros指定的始祖类继承下来，只有这样插件才能获得老祖宗的能力，被Ros的插件系统所接纳。所以的插件都有对应的始祖类，在ros的navigation源代码中，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744362890001-bcb131aa-d50e-435f-8075-20ffee907412.png)

比如咱们要实现的局部规划器，它的老祖宗就是这个base_local_planner，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744363047988-d1c16c81-6feb-4d92-ab7c-cc27d23d1c2a.png)

咱们<font style="color:#DF2A3F;">只需要定义一个新的类，将这个始祖类继承下来</font>，就能成为一个血统纯正的局部规划器。



第2个条件，就是需要使用定义好的函数接口，从move_base节点宿主获取数据和发送数据，

像导航架构图中，传给局部规划器和从局部规划器传出来的数据，都有一些定义好的函数接口，咱们<font style="color:#DF2A3F;">只需要按照这些接口要求来编写代码就行了</font>，那么这些函数接口在哪里定义呢？从始祖类中，你可以看到有很多不同的功能。

## 第二节 创建局部规划器框架
### 1、确定规划器名称
首先咱们看看经典的局部规划器是怎么命名的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744363876318-d89f12b2-e91b-476d-8fea-014815f9f0c7.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744363970998-edf2c800-f6a6-4d21-acbd-3bb341ac4484.png)

前面是一些小写的单词用下划线连接，后面是首字母大小的单词拼接起来，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744364136544-d4758cd4-645e-4d16-9862-0c244aa24533.png)

前面这一部分，其实就是namespace命名空间，后面部分，其实就是类的名称。

所以咱就模仿其命名方式，比如，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744364194733-187cc9d8-b5bf-4e26-b2f4-8766584a70d1.png)

### 2、创建软件包
```bash
cd ~/catkin_ws/src
catkin_create_pkg my_planner roscpp pluginlib nav_core
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744371667798-6e1421f1-559c-4874-8120-7e2cf7a4e220.png)

### 3、编写规划器的h文件和cpp源码文件
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744371828294-bab61570-ffac-4b25-aa86-d03cf2afb70c.png)

右键删除，然后再include下新建my_planner.h文件

```cpp
#ifndef MY_PLANNER_H_
#define MY_PLANNER_H_

#include <ros/ros.h>
#include <nav_core/base_local_planner.h>

namespace my_planner
{
    class MyPlanner : public nav_core::BaseLocalPlanner
    {
        public:
            MyPlanner();
            ~MyPlanner();

            void initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros);
            bool setPlan(const std::vector<geometry_msgs::PoseStamped>& plan);
            bool computeVelocityCommands(geometry_msgs::Twist& cmd_vel);
            bool isGoalReached();
    };
} // namespace my_planner

#endif  // MY_PLANNER_H_
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744372658233-3dd1aa94-4601-47a7-87e1-6b97e5957eef.png)

public表示这个类接下来对外公开的接口函数，

第一个是构造函数<font style="color:#DF2A3F;">MyPlanner</font>，名字和类的名字一模一样，这是规划器诞生的时候会调用的函数，一般会在里面进行变量的初始化，数组的内存空间申请这类操作，

第二个是析构函数<font style="color:#DF2A3F;">~MyPlanner</font>，是这个规划器被销毁时会调用的函数，通常都是和构造函数相反的操作，

下面开始是局部规划器的固定接口，

首先是初始化函数<font style="color:#DF2A3F;">initialize</font>，会在规划器被move_base加载时调用，和构造函数不同的是，构造函数被调用的时候肯Ros还没有启动，所以不能进行话题的订阅和发布操作，而初始化操作时，Ros系统已经启动了，所以一些话题的订阅和发布，以及参数的读取，通常都放在这个初始化函数里，

注意！这个初始化函数在历史上发生过变动，如果是ubantu16.04及之前版本，它的参数是下面这样的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744373399284-87491091-37c7-476c-841f-67c7fd3c8cd5.png)

然后下面这个<font style="color:#DF2A3F;">setPlan</font>，是接收来自全局规划器的全局导航路线的函数，

在navigation架构图中，对应的是这条红线，全局规划器传过来，咱们接收，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744374129979-ad21d2d0-8f1c-4a3f-9d97-bbf2fb4c7924.png)

这个函数的参数，里面装的就是全局导航路线，

然后<font style="color:#DF2A3F;">computeVelocityCommands</font>函数，这个是用来计算速度的，

对应的是这条红线，是从咱们的规划器向机器人发送速度控制指令的函数，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744374409169-0747fbe2-23d3-46f5-b21d-e601c51b64f4.png)

注意！这里咱们不用专门去发布速度话题，只要对参数传进来的这个cmd_vel消息包进行赋值就行了，

剩下的发送操作move_base会替咱们完成，

最后一个 isGoalReached函数，是咱们的规划器向宿主move_base提交导航结果的函数，这个函数会被move_base不停的调用，相当于move_base不停的问咱们规划器，哎呀，怎么样啊，到没到目的地啊，

如果到了咱们就在函数里返回true，没到就返回false，

到这里就是一个血统纯正的局部规划器了，下面咱们把这些函数的内容都实现一下。



在myplanner/src中，新建my_planner.cpp文件，

```cpp
#include "my_planner.h"
#include <pluginlib/class_list_macros.h>

PLUGINLIB_EXPORT_CLASS(my_planner::MyPlanner, nav_core::BaseLocalPlanner)

namespace my_planner
{
    MyPlanner::MyPlanner()
    {
        setlocale(LC_ALL, "");
    }
    MyPlanner~MyPlanner()
    {}

    void MyPlanner::initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)
    {
        ROS_WARN("该我上场表演了！")
    }
    bool MyPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& plan)
    {
        return true;
    }
    bool MyPlanner::computeVelocityCommands(geometry_msgs::Twist& cmd_vel)
    {
        return true;
    }
    bool MyPlanner::isGoalReached()
    {
        return false;
    }
    
} // namespace name

```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744376479021-fa607e82-2bbd-4473-b1d6-e7f33d1d7dd9.png)

先来判断一下咱们规划器有没有被正确加载，其他具体内容后面再补充。

### 4、CMakeLists.txt添加编译规则
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744376842341-8059aafe-bfc4-4008-81b0-b712ea380489.png)

将第119行的include注释取消掉，这样这个include文件夹就会加到头文件搜索路径里，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744377040093-97985e25-9103-4938-b9af-21e2711ae469.png)

将124-126行取消注释，并修改，静态库文件的名字my_planner，编译的源码文件是src文件夹下的my_planner.cpp，

然后将第147行复制去除注释，将${PROJECT_NAME}_node改为my_planner，

最后将找到第152行，同样操作。

```cpp
include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

## Declare a C++ library
add_library(my_planner
  src/my_planner.cpp
)
add_dependencies(my_planner ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
target_link_libraries(my_planner
  ${catkin_LIBRARIES}
)
```

### 5、编写插件描述xml文件
告诉Ros系统，咱们这有个新来的规划器需要进行登记注册，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744377657242-b49fe3c4-cbe1-451a-9c99-530f5a05cab2.png)

在my_planner文件夹目录下新建my_planner_plugin.xml，

```xml
<library path="lib/libmy_planner">
  <class name="my_planner/MyPlanner" type="my_planner::MyPlanner" base_class_type="nav_core::BaseLocalPlanner">
    <description>
      老子的规划器
    </description>
  </class>
</library>
```

### 6、CMakeLists.txt添加描述文件安装规则
第195行，去掉注释符号，并修改文件名，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744378313376-8eb452fc-2bc2-437f-939e-f8e099dedc9b.png)

```xml
## Mark other files for installation (e.g. launch and bag files, etc.)
install(FILES
  my_planner_plugin.xml
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
)
```

### 7、package.xml添加插件描述文件地址
在package.xml的第67行的export标签里，添加一行，

```xml
  <!-- The export tag contains other, unspecified, tags -->
  <export>
    <!-- Other tools can request additional information be placed here -->
    <nav_core plugin="${prefix}/my_planner_plugin.xml"/>
  </export>
```

nav_core指的是导航相关的插件，${prefix}指的是咱们这个my_planner的软件包地址。

### 8、编译软件包
编译之前，再次检测一下几个文件中，各种名称是否一致

（命名空间、规划器类的名称、始祖类的名称、库文件名、插件描述文件的名字）

```xml
catkin_make
source ./devel/ssetup.bash
rospack plugins --attrib=plugin nav_core
```

使用如下指令检测插件是否注册成功，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744379483245-58a088c7-4b7c-43c4-97d5-544497967aca.png)

```xml
ht@ht-VirtualBox:~/catkin_ws$ source ./devel/setup.bash
ht@ht-VirtualBox:~/catkin_ws$ rospack plugins --attrib=plugin nav_core
teb_local_planner /opt/ros/noetic/share/teb_local_planner/teb_local_planner_plugin.xml
dwa_local_planner /opt/ros/noetic/share/dwa_local_planner/blp_plugin.xml
move_slow_and_clear /opt/ros/noetic/share/move_slow_and_clear/recovery_plugin.xml
carrot_planner /opt/ros/noetic/share/carrot_planner/bgp_plugin.xml
global_planner /opt/ros/noetic/share/global_planner/bgp_plugin.xml
base_local_planner /opt/ros/noetic/share/base_local_planner/blp_plugin.xml
rotate_recovery /opt/ros/noetic/share/rotate_recovery/rotate_plugin.xml
wpbh_local_planner /home/ht/catkin_ws/src/wpb_home/wpbh_local_planner/wpbh_local_planner_plugin.xml
navfn /opt/ros/noetic/share/navfn/bgp_plugin.xml
my_planner /home/ht/catkin_ws/src/my_planner/my_planner_plugin.xml
clear_costmap_recovery /opt/ros/noetic/share/clear_costmap_recovery/ccr_plugin.xml
ht@ht-VirtualBox:~/catkin_ws$ 
```



接下来回到wpb_demo_nav.launch的move_base节点，更换规划器重新运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744379778853-9e55d293-1d38-479e-8c32-71a4f53ee2c5.png)

```xml
roslaunch wpr_simulation wpb_demo_nav.launch
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744380048077-3b9d2fb8-d3fe-4090-b33f-14ee6169ae2c.png)

可以看到信息，<font style="color:#DF2A3F;">该我上场表演了!</font>

说明咱们的局部规划器加载成功了。

---



![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744378825439-3c7da2b6-4e82-4a03-b4f3-575c597b4de5.png)

## 第三节 局部规划器的函数机制
在上一节，咱们搭建了局部规划器的完整框架，

在代码功能实现之前，咱们需要了解这几个函数的调用机制，这样才能更好的规划代码部署。

### 1、构造函数MyPlanner
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744425426265-9f852d61-41cc-4ca1-a1f9-390cae167ba1.png)

它是最先被调用的函数，当咱们的规划器对象被创造出来，还没开始工作，这个构造函数就被调用了，所以在这个构造函数里，只能做一些变量的初始化操作，还不能去订阅和发布话题。

### 2、初始化函数Initialize
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744426024216-d6e4d6c5-dd78-4c4c-99dd-b83888552154.png)

这个函数会在宿主节点move_base启动的时候被调用，这个时候Ros系统已经启动起来了，所以可以在这个初始化函数中进行话题的订阅和发布等操作。

### 3、setPlan函数
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744427812078-5ce007a4-a34b-4392-80da-1c292ea42c42.png)

这个函数会在咱们设置导航目标点，生成全局导航路线的时候被调用。

### 4、computeVelocityCommands函数
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744427954095-14ae2765-48d3-4bee-8918-c082eae0046a.png)

这个函数是局部规划器的核心，咱们主要的控制逻辑都写在这个函数里，它会被宿主节点move_base按一个频率不停的调用，这个调用的频率时多少呢？咱们可以在move_base的参数中进行设置，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744428260675-a9db8024-6c96-4572-834a-2c407d1581f0.png)

下拉可以看到，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744428292121-81a6be4b-235e-4bb8-8a5c-5fdb7a6a0cae.png)

注释里说明了这个参数就是控制循环和发布速度的频率，默认数值20.0，也就是20Hz，1s钟循环20次，这就是computeVelocityCommands（）函数被调用的频率。

咱们可以在导航的launch文件中，为move_base节点设置这个参数，以此来调整对底盘速度的控制频率，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744428915090-16295401-53ea-4676-8314-1b768211575c.png)

### 5、isGoalReached函数
这个是用来告诉move_base是否到达导航目标点的函数，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744459490702-4c9c7abe-0d24-4ba0-b1a1-ed84162de063.png)

它和computeVelocityCommands（）函数一样，会被move_base节点以同样的频率进行调用，先调用computeVelocityCommands（），再调用isGoalReached（），如此循环，什么时候结束则看这个函数的返回值。<font style="color:#DF2A3F;">在导航过程中，咱们会让isGoalReached（）返回false，当机器人到达导航目标点时，咱们让它返回true，一旦move_base节点收到这个true返回值，就会跳出这个循环调用，整个导航过程就结束了，恢复到等待下一个导航任务的状态</font>。

### 6、析构函数~MyPlanner
最后，这个规划器的析构函数什么时候被调用呢？

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744459968246-c612255b-ade2-44b3-8426-e869ccd343fc.png)

一般是在整个导航程序退出的时候，在这个函数里做一些收尾工作，该退出的循环，该释放的内存空间，都在析构函数里进行操作。



---

_这就是局部规划器中几个重要函数的调用机制。_

了解了这些调用机制之后，咱们就可以按照自己的控制逻辑，在这些函数中部署不同的功能代码了。

## 第四节 导航路线的获取
咱们局部规划器的主要任务是执行全局规划器发来的全局导航路线，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744460368202-2e35c700-8174-4dbf-84e1-2923809f7c4f.png)

这个路线是在setPlan（）函数中获得的，它的参数plane就是全局导航路线，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744460459477-a5732274-7822-44cd-b3b8-7bfe417c2b5c.png)

这个参数是个vector容器，相当于C语言里的数组，容器里的数组类型是PoseStamped,

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744460641706-eab3d9a5-7680-45c5-a2eb-d187a08d4a94.png)

其实就是把全局导航路线，给分割成了一串连续的点，以及在每个点上，机器人应该朝向的角度，

到底是不是这样呢？咱们可以把这些点画出来，再拿它跟rviz里显示的全局导航路线对比一下，就知道了。

---

咱使用opencv来绘制这条全局路线，首先咱们需要建立一个坐标系，假设咱们以地图原点为中心，画一个大概3米范围内的全局路线，那就是前后各3米，左右各3米，一个6x6米的正方形，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744461113491-dab0fb39-8ca5-410e-9776-a3f285ac8ec7.png)

那咱们就用一个像素为600x600的图片来表示这个正方形区域，也就是100像素的长度表示1米，

在opencv中，图片的坐标系是这样的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744461283096-203058ea-184a-4291-8f5b-458762a57397.png)

在setPlan（）函数中，获得的全局路线点遵循的是Ros坐标系，它的坐标轴方向是这样的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744461379789-8a3652bd-893a-47d4-9b38-32ee51f0b245.png)

可以看到二者X轴和Y轴方向是平行且相反的，计算的时候注意不要搞错了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744461537838-b880c9db-1e63-408b-b40a-8dddc37c374a.png)



打开之前创建的my_planner.cpp，因为要用到opencv，所以引入这两个头文件，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744461715010-3111c99c-95cf-4518-b49a-7c6084595f69.png)

一个用来显示图像窗口，一个用来绘制图片，

```cpp
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
```

然后在setPlan()函数里，将全局导航路线保存下来，放到computevelocityCommands()里进行显示，因为后面我们会在这个函数里控制机器人按照导航路线进行移动，这个全局路线还需要用到很多次，所以这里可以定义一个全局变量，名为global_plan_，类型和setPlan()函数的参数类型一样，然后直接在setPlan（）函数中将参数赋值给它，这样咱们就能在其他函数里读取全局导航路线global_plan_的数值了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744551777212-c2b7ec11-4e50-489d-94b4-939eb3938fa2.png)

然后来到computevelocityCommands()函数，先构建一个600 x 600的opencv图片对象，格式是RGB彩色格式，初始颜色是黑色，然后使用for循环，遍历刚才保存的global_plan_里的所有点，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744552580085-9b75aab8-0292-470e-8569-f06c9dcdf361.png)

用opencv的circle函数，把换算好的路径点，以圆圈的形状绘制在图片对象上，圆圈半径为1个像素，颜色为紫色，然后调用opencv的函数创建一个窗口，把画好路径点的图片显示在这个窗口，延时1ms，让这个图像能够显示操作能够完成，然后保存，准备添加opencv库的编译规则，

```cpp
#include "my_planner.h"
#include <pluginlib/class_list_macros.h>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

PLUGINLIB_EXPORT_CLASS(my_planner::MyPlanner, nav_core::BaseLocalPlanner)

namespace my_planner
{
    MyPlanner::MyPlanner()
    {
        setlocale(LC_ALL, "");
    }
    MyPlanner::~MyPlanner()
    {}

    std::vector<geometry_msgs::PoseStamped> global_plan_;  //定义一个全局变量
    void MyPlanner::initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)
    {
        ROS_WARN("该我上场表演了！");
    }
    bool MyPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& plan)
    {
        global_plan_ = plan;  //在setPlan()函数里赋值全局变量global_plan_
        return true;
    }
    bool MyPlanner::computeVelocityCommands(geometry_msgs::Twist& cmd_vel)
    {
        //构建一个600 x 600的opencv图片对象
        cv::Mat plan_image(600, 600, CV_8UC3, cv::Scalar(0, 0, 0));
        for(int i=0;i<global_plan_.size();i++)
        {
            int cv_x = 300 - global_plan_[i].pose.position.y*100;
            int cv_y = 300 - global_plan_[i].pose.position.x*100;
            cv::circle(plan_image, cv::Point(cv_x,cv_y), 1, cv::Scalar(255,0,255));
        }
        cv::namedWindow("plan"); //把画好路径点的图片显示在这个窗口
        cv::imshow("plan",plan_image);
        cv::waitKey(1);
        return true;
    }
    bool MyPlanner::isGoalReached()
    {
        return false;
    }
    
} // namespace name

```

首先添加一个find_package规则，导入OpenCV的环境设置，

```cmake
find_package(OpenCV REQUIRED)
```

然后找到include_directories规则，添加OpenCV的头文件路径，

```cmake
include_directories(
  include
  ${catkin_INCLUDE_DIRS}
  ${OpenCV_INCLUDE_DIRS}
)
```

在来的target_link_libraries规则，添加OpenCV的库文件列表，

```cmake
target_link_libraries(my_planner
  ${catkin_LIBRARIES}
  ${OpenCV_LIBRARIES}
)
```

然后保存，就可以进行编译了。

```cmake
catkin_make
source ./devel/setup.bash
roslaunch wpr_simulation wpb_demo_nav.launch
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744554184220-99ca9a73-d13a-40ef-9501-aa28d9283cdb.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744554459774-f039504d-43a3-4a76-b88a-93b2feba3dc1.png)

发现rviz里的导航路线和opencv绘制的一模一样，说明这个setPlan()函数的参数确实就是全局导航路线，那后面咱们只需要循着这条路线就能到达导航目的地了。

## 第五节 路径点的坐标转换
在上一节，咱们获得了全局导航路线，理论上只要沿着这条线行走，就能顺利的到达目标点，那沿着这条路线行走，具体该怎么实现呢？

经过前面的实验，咱们已经知道，在局部规划器里，这条全局导航路线已经被分割成一连串的点，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744554713811-a950295f-9ad0-4829-873c-3a74db9d8e90.png)

就好比全局规划器已经脑补了咱们导航运动的全过程，在导航路线上留下了一连串的阴影，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744554825065-f506c61a-ea7a-4338-b68a-6d754844cd85.png)

咱们局部规划器，只需要逐个去追踪这些残影的位置，就可以顺利到达导航目标点了，

说到追踪，可看阿杰入门教程中的这一节，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744554924395-27538947-bb0e-40c3-b153-c959de9a9d04.png)

完全可以按照这个视频的思路，把全局导航路线上的点，视为一个个等待咱们追踪的小球，然后直接把这个追踪算法的思路照搬过来。

这里又有一个新的问题，就是入门教程这个视频里的追踪实验，目标球的坐标值是相对于机器人坐标系的，而咱们现在这些全局路径点，是相对于地图坐标系的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744555356541-8c332725-9df8-4f82-9668-e7e36fde7221.png)

所以这中间还有个坐标系转换的问题，要把全局路径点的坐标值，从地图坐标系转换到机器人坐标系，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744555471529-3ac921e1-057f-4904-b457-fe91a7926a15.png)

这里直接使用Ros中的TF工具，啥样不用算，就能完成坐标系的转换。

下面开始实现：

为了验证坐标系转换的效果，咱们做个实验对比，先看看没有转换前的路线坐标值是怎么变化的，打开咱们的规划器代码文件，找到computeVelocityCommands()函数，可以看到上节课编写的路径点显示代码，咱们在函数的末尾，对参数传进来的速度消息包进行赋值，给它一个z轴的旋转速度，让机器人转起来，

```cmake
cmd_vel.angular.z = 1.0;
```

保存，编译运行看一下，

```cmake
catkin_make
source ./devel/setup.bash
roslaunch wpr_simulation wpb_demo_nav.launch 
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744635072509-e6798d98-f0cd-42b7-994a-c94d4b43b7c7.png)

可以发现机器人转起来了，但是这条路线轨迹还是没有变化，

因为左边轨迹点在地图坐标系，地图不转它就不转，如果转换到机器人坐标系，路线轨迹就会旋转，

<font style="color:#DF2A3F;">下面咱们把这些全局路径点从地图坐标系转换到机器人坐标系</font>，

打开规划器代码文件，首先include 3个tf的头文件，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744635513060-b306f2b3-322a-4539-9e2a-34c04fbf693b.png)

下面咱们需要用到tf工具里一个叫做TransformListener的工具，这个工具会自动监听系统中的tf话题，咱们可以调用它提供的函数，直接完成坐标系转换，那这个工具如何获得呢，咱们在初始化函数的外面定义一个这个工具的指针，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744635781570-1d36d4d8-27ec-4bf2-a995-5e46b5f2b65a.png)

然后再初始化函数里，生成这个工具对象，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744636015493-da59c7e6-4e49-4ea8-8b48-ff9a4241830e.png)

这样做是因为咱们可能在多个函数里操作这个工具，所以需要把它定义为一个全局对象，但是这个工具一出生就会自动订阅tf话题，所以假如咱们把它定义为全局对象，全局对象诞生的时候，Ros系统还没完全启动呢，它这个定义很可能失败，所以只能先定义一个全局指针，然后在初始化函数里生成这个对象，这个时候Ros系统已经启动起来了，它就能顺利的订阅tf话题了，

好，咱们把工具准备好了，看看如何来使用它，

来到computeVelocityCommands()函数，咱们要在这个遍历路径点的循环里，把每个路径点的坐标值都从地图坐标系转换到机器人坐标系，先定义一个临时对象，用来装载转换后的坐标姿态，把导航路线点的消息包时间戳设为当前时间，然后调用tf_listener工具的transformPose函数，将消息包里的全局路径点坐标global_plan_[i]，转换到base_link坐标系，也就是机器人坐标系，转换的结果保存在pose_base里，最后将这组要显示的全局路径点坐标替换为转换后的路径点坐标，

```cmake
for(int i=0;i<global_plan_.size();i++)
{
    geometry_msgs::PoseStamped pose_base;
    global_plan_[i].header.stamp = ros::Time(0);
    tf_listener_->transformPose("base_link",global_plan_[i],pose_base);

    int cv_x = 300 - pose_base.pose.position.y*100;
    int cv_y = 300 - pose_base.pose.position.x*100;
    cv::circle(plan_image, cv::Point(cv_x,cv_y), 1, cv::Scalar(255,0,255));
}
```

保存，然后编译运行，可以发现左边路线轨迹跟着机器人转起来了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744637319361-bd252dc1-8422-4ad0-9fbd-d9a321bd001c.png)

然后下面在显示前加点东西，

```cmake
cv::circle(plan_image, cv::Point(300,300), 15, cv::Scalar(0, 255, 0));
cv::line(plan_image, cv::Point(65,300), cv::Point(510,300), cv::Scalar(0, 255, 0), 1);
cv::line(plan_image, cv::Point(300,45), cv::Point(300,555), cv::Scalar(0, 255, 0), 1);
```

第一句是在图像的中心点位置，画一个半径15像素的圆，颜色为绿色，

第二句是在图像上画一个线段，电锯也是画线段，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744637825376-e4be6002-28f2-406e-8d2e-43c1b24657a9.png)

编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744638943559-8fd8840e-7f3a-4f02-bace-241a875a0e7e.png)

完整代码：

```cmake
#include "my_planner.h"
#include <pluginlib/class_list_macros.h>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <tf/transform_datatypes.h>

PLUGINLIB_EXPORT_CLASS(my_planner::MyPlanner, nav_core::BaseLocalPlanner)

namespace my_planner
{
    MyPlanner::MyPlanner()
    {
        setlocale(LC_ALL, "");
    }
    MyPlanner::~MyPlanner()
    {}

    std::vector<geometry_msgs::PoseStamped> global_plan_;  //定义一个全局变量
    tf::TransformListener* tf_listener_; //定义tf监听指针
    void MyPlanner::initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)
    {
        ROS_WARN("该我上场表演了！");
        tf_listener_ = new tf::TransformListener();  //生成tf工具对象
    }
    bool MyPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& plan)
    {
        global_plan_ = plan;  //在setPlan()函数里赋值全局变量global_plan_
        return true;
    }
    bool MyPlanner::computeVelocityCommands(geometry_msgs::Twist& cmd_vel)
    {
        //构建一个600 x 600的opencv图片对象
        cv::Mat plan_image(600, 600, CV_8UC3, cv::Scalar(0, 0, 0));
        for(int i=0;i<global_plan_.size();i++)
        {
            geometry_msgs::PoseStamped pose_base;
            global_plan_[i].header.stamp = ros::Time(0);
            tf_listener_->transformPose("base_link",global_plan_[i],pose_base);

            int cv_x = 300 - pose_base.pose.position.y*100;
            int cv_y = 300 - pose_base.pose.position.x*100;
            cv::circle(plan_image, cv::Point(cv_x,cv_y), 1, cv::Scalar(255,0,255));
        }
        cv::circle(plan_image, cv::Point(300,300), 15, cv::Scalar(0, 255, 0));
        cv::line(plan_image, cv::Point(65,300), cv::Point(510,300), cv::Scalar(0, 255, 0), 1);
        cv::line(plan_image, cv::Point(300,45), cv::Point(300,555), cv::Scalar(0, 255, 0), 1);

        cv::namedWindow("plan"); //把画好路径点的图片显示在这个窗口
        cv::imshow("plan",plan_image);
        cv::waitKey(1);

        cmd_vel.angular.z = 1.0;

        return true;
    }
    bool MyPlanner::isGoalReached()
    {
        return false;
    }
    
} // namespace name

```

## 第六节 导航路线追踪
上节课咱们完成坐标系转换，这节课咱们就来实现对这条全局导航路线的追踪，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744639381329-f46d2f14-7916-4da4-b1c6-64bc57e7edb2.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744639256693-c3d2c56b-3431-4407-a997-eebbf8d640e4.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744639583714-f0fd5c5e-2465-4487-8c0f-187a0ecaea2d.png)

现在从第一个点开始追踪，咱们用一个标记点标记它，以免后面忘记，当机器人和这个点的距离小于某个值时，就任务机器人已经到达了这个路径点，这个时候将标记变量跳到下一个路径点，于是机器人开始追踪这个新的路径点，到达后标记变量开始跳到下一个，然后下一个以此类推直到路径的最后一个点，

要实现这样的追踪机制，首先需要一个距离阈值，用来判断是否到达路径点，如果机器人和目标路径点的距离小于这个阈值，就认为已经到达了这个路径点，咱们先给这个阈值取0.2米，后面根据需要进行调整，

然后还需要一个标记变量，用来标记咱们当前要追踪的路径点，给这个变量取个名字叫做target_index，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744639937480-65db43ea-3ffc-48d9-8ad5-98ea33bddd62.png)

<font style="color:#DF2A3F;">下面开始设计整体流程</font>，

导航一开始，先把标记变量target_index_设置为0，表示从导航路线的第一个点开始追踪，

然后当computeVelocityCommands()函数被调用时，会评估一下这个标记变量target_index_所指向的路径点和机器人当前的距离，如果小于0.2米阈值，就判定已经到达了，该去追踪下一个路径点了，

怎么实现这个评估机制呢，这里使用一个for循环，对导航路径点进行一个遍历，for循环的计数变量为i，i的初始值设置为target_index_的值，表示从标记变量指向的路径点开始进行路径的遍历，每遍历到一个新的路径点，都有计算一下它到机器人的距离，然后将这个距离和0.2米的阈值进行比较，如果小于0.2米，就认为机器人已经到达了这个点，继续评估下一个路径点，如此循环，直到找到一个距离大于0.2米阈值的新路径点，把它的序号i赋值给标记变量target_index_，这样下一次遍历时会从这一个路径点开始，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744640713156-67570795-96c8-4d9c-8519-e81450438b5b.png)

当下一次computeVelocityCommands()函数被调用时，会重复这个流程，直到到达导航终点为止。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744640758328-9a641c7d-8124-48f9-ae4c-44772a5aad52.png)



<font style="color:#DF2A3F;">下面开始实现这个流程</font>，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744700210909-e6c13020-0a28-4824-ab9c-de48cdc657a8.png)

首先咱们来定义路径点的标记变量target_index_，

这个变量放在哪里合适呢？从流程图可以看到，可以看到这个target_index_主要是用来记录上一次的路径点遍历，是在哪个位置结束的，然后在下一次遍历的时候，作为新的循环的开始位置，所以这个target_index_是用来在相邻函数调用之间传递数值的，那么咱们就需要把它定义为一个全局变量，

只有这样，它才能在computeVelocityCommands()函数执行完毕之后，才能存活下来，保存好数值，一直到下一次这个函数被调用，

这里给target_index_赋值为0，一般是在跟踪一条新的导航路线时，才会进行的操作，对应到代码，在setPlan()函数，咱们把target_index_定义在外面，成为一个全局变量，然后再这个函数里赋值初始值为0，这样每次产生新的导航路线时，这个标记变量就会重置为0，

```cmake
    int target_index_;  //定义全局标记变量
    bool MyPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& plan)
    {
        target_index_ = 0;
        global_plan_ = plan;  //在setPlan()函数里赋值全局变量global_plan_
        return true;
    }
```

然后来到computeVelocityCommands()函数函数，在这个函数里实现图中的这些逻辑，

先定义一个对象target_pose，一会用来存储目标路径点的信息，然后构建for循环，对导航路线上的路径点进行遍历，起始位置就从target_index_开始，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744701197398-82df872b-66ab-4734-838e-e4a3c4718046.png)

和上一节一样，

```cmake
        geometry_msgs::PoseStamped target_pose;
        for(int i=target_index_;i<global_plan_.size();i++)
        {
            geometry_msgs::PoseStamped pose_base;
            global_plan_[i].header.stamp = ros::Time(0);
            tf_listener_->transformPose("base_link",global_plan_[i],pose_base);
            double dx = pose_base.pose.position.x;
            double dy = pose_base.pose.position.y;
            double dist = std::sqrt(dx*dx + dy*dy);
        }
```

将路径点坐标从地图坐标系转换到机器人坐标系，这组dx和dy就是转换后的路径点坐标值，因为机器人坐标系原点，就是机器人底盘投影的中心点，所以直接求它和坐标原点的距离dist，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744704521053-f5b2ee46-bdc6-405d-8fbe-ce508bf1ba3d.png)

得到的就是这个路径点和机器人的距离，然后将这个距离和2米阈值进行比较，

```cmake
        if(dist > 0.2)
        {
            target_pose = pose_base;
            target_index_ = i;
            ROS_WARN("选择第 %d 个路径点作为临时目标，距离=%.2f", target_index_, dist);
            break;
        }
```

然后break结束这个遍历循环，如果路径点距离小于0.2米，那就不会进入这个判断分支，也就不会执行这个break，最后会进入for循环的下一轮，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744708805222-7a96e500-5b9f-4e0f-b5f1-3b8400921cfd.png)

执行这个i++，继续下一轮评估。



![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744709722410-8627107f-cf97-4c67-baec-b8971d076e71.png)

这是机器人到达最后一个路径点时的特殊处理，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744709804952-9f61fd03-d6a4-4276-826a-fa50d23a3d67.png)

因为这个时候，可以追踪的路径点，就剩最后一个了，而且它还不满足这个距离条件，

如果没有这一段的话，就没法给target_pose赋值了，但是它应该把最后一个路径点作为追踪目标，所以加上这一句，整个机制就严谨了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744710020641-45fb61cc-7266-4611-8f41-83cd4abd8c73.png)

好，最后两句是计算追踪速度值，cmd_vel是参数传递进来的速度消息包，咱们给它赋值，move_base就会发送给机器人执行，target_pose是刚才在遍历过程中确定的追踪目标位置，这个就是对追踪速度的计算，在入门课的目标追踪实验有详细的解释，大概思路就是，让追踪目标相对于机器人的横向偏移量，和机器人的旋转速度挂钩，这样能趋势机器人转动，对准追踪目标，同时让机器人与追踪目标的距离和机器人的前进速度挂钩，这样能驱使机器人靠近追踪目标，通过一个比例控制，实现了目标追踪的效果，这两个数值就是比例系数，可以根据具体情况进行数值的调整，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744710962018-086e4a6f-b69a-450e-b0dc-e254422c30f9.png)

保存然后编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744711667240-818ca12f-10c5-4fb3-bea8-6056616e5a47.png)

## 第七节 目标姿态的处理
咱们在设置导航终点时，设置的导航终点朝向，可不一定和路径方向一致，这个需要咱们规划器在快要到达导航终点时，按照这个终点姿态的朝向，进行必要的处理，怎么弄呢？

只要机器人靠近导航终端，就让机器人转向终点姿态的朝向，

咱们可以把![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744715447839-a78fad03-4b60-4123-ab85-de3392b9de0b.png)

看作一个整体，就叫做导航路线追踪，然后再它的前面加一个前置条件，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744715740817-571990ad-6c7e-4996-82eb-345280b9fa93.png)

先是计算机器人和导航终点的距离，然后和一个距离阈值进行比较，用这个距离阈值来判断它是不是快到终点了，这个阈值咱们先取0.05米，当距离大于等于0.05米，就认为离导航目标还有一定距离，继续执行之前的路线追踪流程，如果和终点距离小于等于0.05米，就认为快到终点了，赶紧调整机器人朝向，去拟合终点姿态，

这里有个问题，就是机器人在转向目标姿态的过程中，有可能会因为里程计误差，或者轮子摩擦等原因，导致定位的旋转中心，偏离了底盘中心，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744716187622-ff3aac9b-2c13-46ce-ad75-599bc7cfe288.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744716260191-d6bbf446-f74a-4fad-9ae5-b2ed0ceb84b9.png)

有时候，机器人转着转着，就和目标点距离偏差超过0.05米，这时候回切换回路线追踪流程，

机器人调头转向终点，转的过程中，可能距离又小于0.05米，又切换到拟合终点姿态，

<font style="color:#DF2A3F;">这样来来回回就出现了震荡</font>，为了避免这种情况，可以把这个拟合目标姿态的过程中，<font style="color:#DF2A3F;">设置一个目标锁定状态</font>，一旦进入锁定状态，就不再理会和终点的距离差了，管你山崩地裂还是洪水滔天！一心一意只完成目标姿态的拟合，在程序流程上，咱们可以这样修改，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744716890245-682a0bf4-f8da-461b-9b96-99ec81bd8648.png)

用一个bool变量来表示这个锁定状态，咱们给这个变量取值pose_adjusting，设置初始值为false，表示还没靠近导航终点，当这个计算速度的接口函数被调用时，会先看看这个锁定变量的值，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744717132840-6fee6684-dc57-4627-8c04-28fe2a4d1acb.png)

如果是false，就走之前的流程，如果是true，就进入拟合终点姿态的步骤，

注意这个pose_adjusting_的作用是用来锁定这个拟合终点姿态，

所以当机器人第一次进入这个状态时，把pose_adjusting_修改为true，这样就变成了，这样就变成了，之后每次执行到![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744719898317-867b542b-246f-4689-845f-a1d2548ea430.png)这个判断条件时，都只会走true这个分支，拟合终点姿态，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744719993772-a2bac639-8176-4a03-a126-87e47559effb.png)

而不会再进入false分支去追踪导航路线了，这样就达到咱们锁定状态的目的，

那这个变量什么时候变回false呢？只有等到下一次新的导航任务时，才会变成false，

那现在，这个拟合终点姿态的状态什么时候结束呢？

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744720201168-300c64f5-9447-43f6-a277-ef5e8b9b21de.png)

咱们把机器人的朝向角，和终点姿态的朝向角进行比较，这里也设置一个阈值，

如果两者差值大于等于0.1弧度，说明还没有调整到位，正常返回，让move_base继续执行这个速度计算函数，继续调整，如果机器人朝向角和终点朝向角小于0.1弧度，则认为机器人的朝向已经和终点姿态基本贴合了，让isGoalReached()函数返回true，告诉move_base本次导航任务已经完成，准备下一次导航任务吧，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744720396706-af36045c-82a8-4f72-8127-29be40d1abe7.png)



下面开始编写代码，

首先是pose_adjusting的初始化，刚才咱们说过，这个变量变为false，是在刚开始执行新的导航任务的时候，也就是这个setPlan函数，规划器领到新的导航任务时，把它初始化为false，

后边就都在这个计算速度的computeVelocityCommands函数里使用它了，

这个变量跨越多个函数，因此需要设置为全局变量，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744770948419-8f28e137-5622-4f64-b214-f3eaaabdec7b.png)。

在computeVelocityCommands函数中，

```cmake
        int final_index = global_plan_.size() - 1;
        geometry_msgs::PoseStamped pose_final;
        global_plan_[final_index].header.stamp = ros::Time(0);
        tf_listener_->transformPose("base_link",global_plan_[final_index],pose_final);
```

finnal_index是导航终点的序号，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744771794542-dc039d01-a54d-4a49-969f-cff1382f2968.png)用来获取导航终点在地图坐标系的姿态，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744771844278-80168e33-7817-4997-86d3-327a5bf7caf1.png)

这三句代码，上一节用过很多次了，

把导航终点的姿态数据转换到base_link机器人坐标系，转换结果存储到这个pose_final里，

然后，开始实现pose_adjusting__ == false这个分支，计算机器人与导航终点的距离，然后根据这个距离值进行分叉，如果距离小于0.05，说明机器人快到导航终点了，就执行这两步操作，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744772575795-57a14b92-c3d2-4c4c-a4a4-929a456cc6c2.png)

把机器人锁定在拟合最终姿态的分支，这里这两个操作的实现顺序反了一下，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744772627943-db58ecfa-750a-4ed0-9d04-bd64573336a1.png)

不过没关系，谁先谁后效果都一样，

final_yaw是导航终点姿态在机器人坐标系里的偏差角（<font style="color:#DF2A3F;">就是机器人朝向角和终点姿态朝向角的差值</font>），偏差角乘上一个比例系数作为旋转速度，就能让机器人转向导航终点的姿态，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744773263207-bf319ce2-2894-445c-af67-351c308a5381.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744773292004-e460c623-2998-464a-826c-598e52d2f160.png)

这个比例系数可以根据具体表现来调整大小，

接下来，将机器人朝向角和终点姿态朝向角进行比较，也就是这个偏差角，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744773420184-6415136a-41fd-4d01-90be-0dae6ee6404d.png)

如果偏差角小于0.1弧度，则认为已经到达导航终点姿态了，速度设置为0，让机器人停在终点姿态，

然后让isGoalReached()函数返回true，告诉move_base导航任务完成，又是一个跨函数的操作，咱用过全局变量来实现吧，这个全局变量咱们命名为goal_reached_，在初始化函数前定义，在初始化函数里赋值false，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744774181247-4384f47f-da71-420a-80dd-8d6d3a57b6eb.png)

然后来到isGoalReached()函数，让它返回这个全局变量goal_reached_，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744774241471-204642a7-77f7-437b-b040-8e84226914ef.png)

然后大于等于0.1弧度怎么实现呢？就是这个return，直接结束这一次的速度计算，等待下一次这个函数被调用，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744774446713-98c3619c-d251-41f9-8420-1015c2653785.png)

最后这个分支，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744774542628-6ea77577-4521-4dd6-9267-abf8f1c26c90.png)

它前置两个条件，一个是这个pose_adjusting_需要为false，然后是机器人和导航终点距离大于等于0.05米，那它就不符合这个条件，pose_adjusting_也不会被修改为true，接着就不会进入![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744774700577-896a7f56-17c3-4fee-961d-52fb399cd265.png)这个条件分支，直接进行导航路线追踪。

保存，然后编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744775469383-97f1a676-5098-43ec-a5b6-5490cdfc44c0.png)

到这里，咱们的机器人已经能在一个没有障碍物的环境里进行导航了。

```cpp
#include "my_planner.h"
#include <pluginlib/class_list_macros.h>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <tf/transform_datatypes.h>

PLUGINLIB_EXPORT_CLASS(my_planner::MyPlanner, nav_core::BaseLocalPlanner)

namespace my_planner
{
    MyPlanner::MyPlanner()
    {
        setlocale(LC_ALL, "");
    }
    MyPlanner::~MyPlanner()
    {}

    std::vector<geometry_msgs::PoseStamped> global_plan_;  //定义一个全局变量
    tf::TransformListener* tf_listener_; //定义tf监听指针
    void MyPlanner::initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)
    {
        ROS_WARN("该我上场表演了！");
        tf_listener_ = new tf::TransformListener();  //生成tf工具对象
    }
    int target_index_;  //定义全局标记变量
    bool pose_adjusting_;
    bool goal_reached_;
    bool MyPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& plan)
    {
        target_index_ = 0;
        pose_adjusting_ = false;
        global_plan_ = plan;  //在setPlan()函数里赋值全局变量global_plan_
        goal_reached_ = false;
        return true;
    }
    bool MyPlanner::computeVelocityCommands(geometry_msgs::Twist& cmd_vel)
    {
        int final_index = global_plan_.size() - 1;
        geometry_msgs::PoseStamped pose_final;
        global_plan_[final_index].header.stamp = ros::Time(0);
        tf_listener_->transformPose("base_link",global_plan_[final_index],pose_final);

        if(pose_adjusting_ == false)
        {
            double dx = pose_final.pose.position.x;
            double dy = pose_final.pose.position.y;
            double dist = std::sqrt(dx*dx + dy*dy);
            if(dist < 0.05)
                pose_adjusting_ = true;
        }
        if(pose_adjusting_ == true)
        {
            double final_yaw = tf::getYaw(pose_final.pose.orientation);
            ROS_WARN("调整最终姿态, final_yaw = %.2f", final_yaw);
            cmd_vel.linear.x = pose_final.pose.position.x * 1.5;
            cmd_vel.angular.z = final_yaw * 0.5;

            if(abs(final_yaw) < 0.1)
            {
                goal_reached_ = true;
                ROS_WARN("到达终点！");
                cmd_vel.linear.x = 0;
                cmd_vel.angular.z = 0;
            }
            return true;
        }


        geometry_msgs::PoseStamped target_pose;
        for(int i=target_index_;i<global_plan_.size();i++)
            {
                geometry_msgs::PoseStamped pose_base;
                global_plan_[i].header.stamp = ros::Time(0);
                tf_listener_->transformPose("base_link",global_plan_[i],pose_base);
                double dx = pose_base.pose.position.x;
                double dy = pose_base.pose.position.y;
                double dist = std::sqrt(dx*dx + dy*dy);

                if(dist > 0.2)
                {
                    target_pose = pose_base;
                    target_index_ = i;
                    ROS_WARN("选择第 %d 个路径点作为临时目标，距离=%.2f", target_index_, dist);
                    break;
                }

                if(i == global_plan_.size() - 1)
                target_pose = pose_base;
        }
        cmd_vel.linear.x = target_pose.pose.position.x * 1.5;
        cmd_vel.angular.z = target_pose.pose.position.y * 5.0;

        //构建一个600 x 600的opencv图片对象
        cv::Mat plan_image(600, 600, CV_8UC3, cv::Scalar(0, 0, 0));
        for(int i=0;i<global_plan_.size();i++)
        {
            geometry_msgs::PoseStamped pose_base;
            global_plan_[i].header.stamp = ros::Time(0);
            tf_listener_->transformPose("base_link",global_plan_[i],pose_base);

            int cv_x = 300 - pose_base.pose.position.y*100;
            int cv_y = 300 - pose_base.pose.position.x*100;
            cv::circle(plan_image, cv::Point(cv_x,cv_y), 1, cv::Scalar(255,0,255));
        }
        cv::circle(plan_image, cv::Point(300,300), 15, cv::Scalar(0, 255, 0));
        cv::line(plan_image, cv::Point(65,300), cv::Point(510,300), cv::Scalar(0, 255, 0), 1);
        cv::line(plan_image, cv::Point(300,45), cv::Point(300,555), cv::Scalar(0, 255, 0), 1);

        cv::namedWindow("plan"); //把画好路径点的图片显示在这个窗口
        cv::imshow("plan",plan_image);
        cv::waitKey(1);

        //cmd_vel.angular.z = 1.0;  //机器人旋转速度

        return true;
    }
    bool MyPlanner::isGoalReached()
    {
        // return false;
        return goal_reached_;
    }
    
} // namespace name

```

## 第八节 代价地图的参数优化
为了给局部规划器添加避障功能，咱们需要获取局部代价地图，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744787744118-f9eed0c4-c031-4dbc-8669-90335ddd675a.png)

代价地图里的障碍物分布情况，将成为避障决策的重要依据，因此，咱们需要检查一下代价地图里的参数设置，确保咱们在局部规划器中，能获得正确的地图数据，

关于代价地图的参数设置，在之前的入门课程已经有过介绍，大部分参数使用默认值就可以了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744787960233-017c3044-4b4b-4b82-baea-a09a62966e3e.png)

为了保险起见，这里咱们需要再次确认一些关键参数，注意有下面这些，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744788101193-6cb11bc7-f137-4480-ab07-9f814dca6790.png)

这些参数通常在move_base节点的这几个yaml文件里，文件名中都带costmap关键词，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744788195948-72929c7b-b7d9-4152-a9a5-d7cf364358db.png)

其中影响局部代价地图的是下面这两个参数文件，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744788354447-488515cb-5a0a-49e3-9965-5ff71e7c05ea.png)



注意：同名参数，后面的yaml会覆盖前面的yaml。

---

可以注意到，在初始化函数的参数中，有个costmap_ros，这个就是存放代价地图的对象指针，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744788824293-41db7075-c2e3-43ff-9233-72947c297c64.png)

咱们需要再初始化函数中将这个指针对象保存下来，然后再计算速度的函数中用它来获取代价地图。

---

又是一个跨函数的操作，所以需要一个全局变量来传递这个指针，咱们在初始化函数前定义一个全局变量![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744789100605-fdf07d2e-de51-4275-a309-b6fa9d2b4e7d.png)

然后再初始函数中，将代价地图指针给保存在全局变量中，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744789204350-6d1485d2-8ae0-43fd-bb10-2a10be6dd299.png)

在计算速度的函数computeVelocityCommands函数中获取代价地图，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744789608521-de25c96c-dcb6-4d8e-9c93-83a7af973ab4.png)

注意这个costmap和上面定义不同，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744789714783-7398a4b5-5056-4522-90be-f165fc744d77.png)

首先咱们调用带尾巴costmap_ros的getCostmap()函数，获取不带尾巴的cosmap，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744790117818-6a3a9801-9e92-4a85-be3b-4d51ed5a83f4.png)

然后调用costmap的getCharMap函数获取代价地图的栅格值数组，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744790278608-094b4041-a820-4b23-b63f-aa359d05350f.png)

然后调用getSizeIncellsX和getSizeIncellsY这两个函数分别获取代价地图的X轴栅格数和Y轴栅格数，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744790308236-20d479e6-7ea7-4b68-b544-9775b1299e79.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744790393590-20cf7dfc-7b01-4f81-b0e7-294974be7969.png)

然后<font style="color:#DF2A3F;">使用OpenCV窗口来显示这个代价地图</font>，

先构建一个图片对象，图像的长宽和代价地图的长宽尺寸一致，RGB彩色格式，初始颜色为灰色，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744790587089-fc791544-1503-4bc7-a6cc-4f4d672bfe7c.png)

接下来使用嵌套的for循环对代价地图的栅格进行逐个遍历，

```cpp
        // 获取代价地图的数据
        costmap_2d::Costmap2D* costmap = costmap_ros_->getCostmap();
        unsigned char* map_data = costmap->getCharMap();
        unsigned int size_x = costmap->getSizeIncellsX();
        unsigned int size_Y = costmap->getSizeIncellsY();

        // 使用OpenCV绘制代价地图
        cv::Mat map_image(size_y, size_x, CV_8UC3, cv::Scalar(128,128,128));
        for(unsigned int y = 0; y < size_y; y++)
        {
            for(unsigned int x = 0; x < size_x; x++)
            {
                int map_index = y * size_x + x;
                unsigned char cost = map_data[map_index];                 //从代价地图数据取值
                cv::Vec3b& pixel = map_image.at<cv::Vec3b>(map_index);    //获取彩图对应像素地址

                if(cost == 0)    //可通行区域
                    pixel = cv::Vec3b(128, 128, 128);   //灰色
                else if(cost == 254)   //障碍物
                    pixel = cv::Vec3b(0, 0, 0);         //黑色
                else if(cost == 253)   //禁行区域
                    pixel = cv::Vec3b(255, 255, 0);     //浅蓝色
                else
                {
                    // 根据灰度值显示从红色到蓝色的渐变
                    unsigned char blue = 255 - cost;
                    unsigned char red = cost;
                    pixel = cv::Vec3b(blue, 0, red);
                }
            }
        }
```

这个map_index是根据x、y的坐标值，计算出其在一维数组中对应的下标值，然后通过这个下标值，就能读取这组x、y下标对应的栅格的代价值了，同样的使用这个下标值，也能获取图像对象中x、y坐标对应的像素地址，下面就可以根据读到的代价值，在图片中对应位置显示不同的颜色。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744791140091-bd53ced1-f38b-43b0-8359-2ce063b5aab2.png)

给代价地图涂完颜色后，在彩色图像的中心点标记一个绿色点表示中心点，表示机器人底盘中心所处的位置，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744792388179-348b914e-7a4d-4035-aa22-949e1d70ebcb.png)

然后添加窗口显示，把代价地图的尺寸和窗口尺寸放大5倍显示。

```cpp
        map_image.at<cv::Vec3b>(size_y/2, size_x/2) = cv::Vec3b(0, 255, 0);  //机器人位置

        // 显示代价地图
        cv::nameWindow("Map");
        cv::resize(map_image, map_image, cv::Size(size_y*5, size_x*5), 0, 0, cv::INTER_NEAREST);  //尺寸放大5倍
        cv::resizeWindow("Map", size_y*5, size_x*5);
        cv::imshow("Map", map_image);
```

保存，编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744793060921-ef43d8f9-a0ae-4553-ab5d-0e497554c265.png)

可以发现得到的地图肯定是时有问题的，

需要对绘制好的地图进行一个翻转，先沿对角线进行一个翻转，对调一个x轴和y轴，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744793299785-0ec850d4-15a6-409c-bed4-5ac7c765ad55.png)

然后沿横向中线和纵向中线进行翻转，让x轴和y轴的方向进行翻转，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744793429616-0a23ebb8-f545-433d-a3ec-c7c41307f1d3.png)

---

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744793579889-b686b272-7239-4c1a-a368-22db2588df5e.png)

重新编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744794635173-ca76f08d-114a-4a35-a4bb-a590d05279eb.png)

虚拟机里面颜色比较浅不知道为啥。

## 第九节 代价地图的导航路线
要在导航里实现避障，就需要知道障碍物有没有挡住导航路线，

那么如何知道障碍物在导航地图里的分布呢？这一节就来解决这个问题。

在前面的视频里，直到了导航路线是由一连串离散的坐标点组成，这些导航路线点的坐标值是基于地图坐标系的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744795593823-ecb5b7ed-0020-43f7-9d3e-f15f3c6137db.png)

而咱们的局部代价地图，它的坐标系是在这个local_costmap_params.yaml参数文件中设置的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744795649078-391206df-79be-406e-a432-9333fdf46fb8.png)

坐标系名称设置在local_costmap名下的global_frame，一般设置为odom，里程计坐标系，

那代价地图的原点是不是就是里程计坐标系的原点呢？其实跟这个滑动窗口rolling_window有关，

如果设置为true，代价地图就会跟着机器人移动，如果设置为false，那代价地图的原点就会和全局坐标系融合，<font style="color:#DF2A3F;">一般建议的方式，将代价地图的尺寸</font>![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744796241709-8638b672-574b-4c57-9a1f-d3d669e4a4c6.png)<font style="color:#DF2A3F;">设置的比较小，然后滑动窗口设置为true</font>。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744796336440-b6960b59-e1bd-4fcb-990d-0dccdd7ab217.png)

用来获取代价地图的原点在全局坐标系里的坐标值（orig_x，orig_y），通过这组坐标值就能计算出全局导航路径点在局部代价地图里的坐标值（local_x，local_y）,

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744796410473-6a031bc8-ea83-4d28-a094-eed932a01292.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744796446137-cfc1d329-dd92-4051-b82b-9375fe93d7be.png)

可以想象出，导航路线点在局部代价地图中是不断变化的，所以咱们需要不停的计算它们的最新坐标值。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744796791149-1915e537-9cf1-45c9-9437-dd4610333a86.png)



打开my_planner.cpp，开始编写代码，

咱们在翻转地图前面进行操作，

首先通过一个for循环，对全局路径点进行遍历，对遍历到的每一个点进行坐标系转换，

从原生的坐标系，一般是map坐标系，转换到odom坐标系，得到的这组坐标值，就是![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744797937461-c6bd8b55-3a37-4c2a-a2e2-37b99b70f501.png)这组坐标值，

然后获取代价地图原点在全局坐标系里的坐标值，也就是![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744798012833-c983d2bb-0d4d-4e84-a282-7c4036adb921.png)这组数值，

然后将两组坐标值进行相减，就能得到![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744798088450-186e0e51-fb91-494c-bd2f-4cd88203cd16.png)导航路线点在局部代价地图里的坐标值，

注意：这个坐标值单位是米，还不是栅格地图的坐标值，需要除以代价地图的分辨率，

也就是栅格地图里，单个栅格的边长，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744798260074-f306cfb3-9470-43f4-9053-5572eaa19ac3.png)

这样才能得到路径点在栅格地图里的坐标值。

最后使用OpenCV里的circle函数在局部代价地图的栅格图中，路线点所在的栅格处画一个圆，圆的半径为0，其实就是画了一个点，这个点的颜色为紫色，这就和rviz中显示的一样了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744798503803-6cbe4bd7-939d-4972-aa6e-9fccb2aa4591.png)

保存，编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744798592999-f895eb3d-602c-4348-9ec7-b3c2599bde95.png)

---

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744799466759-6004e965-b27b-4025-b70d-fa0aeef43e15.png)

## 第十节 动态避障的实现
在前面的内容里，咱们已经获取了代价地图以及导航路线，并把他们统一到了同一个坐标系中，这样就可以通过对导航路线上的代价值进行读取，来检测是否有障碍物挡住了导航路线。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744799759988-0b3579a7-12a7-493e-9358-a758ad457b4f.png)

咱们可以从这个要跟踪的路线点开始，再往后多检测几个点，读取他们在代价地图里对应的代价值，来看看是否在障碍物和禁行区域里，以此来判断前方是否有障碍物，如果有障碍物，那就要采取措施进行避障，如果没有障碍物，那就执行常规的路线追踪行为。

---

打开规划器源码文件，找到上一节绘制导航路线的代码，

这个for循环是对整条导航路线的坐标点进行遍历，路线点的坐标计算都已经写好了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744800284656-e295bbf8-2244-4165-aabb-dd0feeeeec13.png)

那咱们就把路线点的障碍物检测也写在这个for循环里面，直接用这组计算好的坐标值，省的再算一遍，

首先，咱们要检测临时路线点及它之后几个路线点对应的代价值，那就需要知道这个标记变量的值，这个标记变量前面定义过为target_index。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744805742884-78669637-d2bd-4a80-9cce-f962f9181372.png)

+10就是往后的第10个点，中间路线点都在检测范围之内，10个点的距离其实就是10乘以地图分辨率，

地图分辨率也就是地图单个栅格的边长，这个在地图的yaml文件里有定义，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744805809732-27643231-daf0-468b-be11-b7dc8de5c5fe.png)

使用gmapping建图的话通常是0.05米，10个点就是0.5米距离，即检测半米内的障碍物，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744806352696-3da2039c-18a4-47bc-ba4f-ddab7a794e22.png)

如果10个路线点里，只要有一个点它对应的代价值大于或等于253，咱们就判断前方有障碍物，该避障了，这个避障操作，只有一句return false，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744806448686-f56a874e-7e87-4bf7-a275-73efed96bb81.png)

返回false就会出现相反的情况。通过返回值激活全局规划机制，避免由于局部视角无法完成新路线规划。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744806925055-63377933-4c45-477c-a557-9ddecc7f668c.png)



## 第十一节 全向移动的功能扩展
首先找到wpb_demo_nav.launch文件，找到amcl节点，修改如下

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744811821666-64851705-9210-41cb-b810-f12b08ea407f.png)

让amcl适应全向模式下的里程计，否则amcl会按照差动模式对里程计进行处理。

当咱们的机器人沿着Y轴侧向移动时，amcl会认为这个侧向平移是里程计的误差，会对这个侧向位移进行纠偏，结果就会![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744808503528-3593c708-4feb-4f32-977b-4ca07bbd9fe1.png)，反而造成巨大的定位误差，

如果设置这个全向模式参数，当机器人侧向平移时，amcl就能正常定位了。

设置完全向模式之后，就可以修改规划器代码文件了，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744808739164-65f8729f-57df-4d56-b19a-8c4c5c4a7aa3.png)

将机器人的Y轴平移速度，和移动目标点相对于机器人在Y方向上的距离偏差值，建立一个比例关系，比例系数也是1.5，这样单单靠这组X和Y方向上的速度就可以完成导航路线追踪的功能了，剩下来的旋转速度就可以解放出来随便设置了，这里给个1.0的速度，单位是弧度每秒。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744809102650-58c91230-b39c-4e50-9190-9297396c08a8.png)

编译运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744809975602-735e04cf-a974-480d-af58-fdda38b3512b.png)

---

让机器人导航的时候，时刻朝向某个点，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744809931069-9719839c-2cd6-4f9f-b246-044755911feb.png)

比如，让机器人朝向时刻朝着这个门口，相对于地图原点的坐标为（1，-1.5），一格距离为1。

先定义两个姿态消息包，一个是门在地图坐标系中的坐标姿态，一个是门在机器人坐标系中的坐标姿态，

然后把门在地图坐标系的坐标值赋值给第一个姿态消息包，姿态的朝向也需要赋值，注意这个朝向是四元数，赋值一定要是合法的数值，最简单的就是只给w赋值1.0，其他的xyz维持默认值0，然后指定地图坐标系为地图坐标，打上时间戳，接着调用tf转换函数，将这个门在地图坐标系的姿态，转换到base_link机器人坐标系下的姿态，转换结果在pose_base里，最后按照前面追踪路线导航点的方法，把门在机器人坐标系里的y值乘以一个比例系数作为机器人的旋转量。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744810234623-8fef4666-e862-4b2b-81c5-2437c0d7fdf6.png)

编译运行，... 有点报错，不知道为啥

## 第十二节 局部规划器的移植部署
以睿抗tianracer竞速比赛框架为例，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744858328630-601391ce-adbc-4170-a96a-a36da512b212.png)

```cpp
git clone https://github.com/tianbot/tianracer.git -b dev

roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=test_indoor
系统环境变量 export TIANRACER_WORLD=test_indoor
rosrun tianracer_gazebo judge_system_node.py

roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=raicom
系统环境变量 export TIANRACER_WORLD=raicom
rosrun tianracer_gazebo judge_system_node.py
```

---

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744858445334-8140db84-d297-4f51-9dff-1df67a5455e6.png)

默认使用的teb规划器。

怎么让自己的规划器起作用呢？

前面是找到wpb_demo_nav.launch文件里，找到move_base节点的base_local_planner，修改为自己的规划器，这里依然是类似操作，

首先打开刚才运行的launch文件，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744858932655-9b5df0d1-f7d1-4dee-bb8f-852e8d65507c.png)

然后打开teb_base.launch.xml文件，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744859043054-963c902a-713e-4325-9bc9-4166ed1d1e05.png)

修改为咱们自己的规划器名称，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744859264161-0f139b2c-0b11-422c-988c-15ddcf124326.png)

报错：在执行坐标系转换时，目标坐标系base_link不存在，

打开tf树，发现base_link前面多了个tianracer，

```cpp
rosrun rqt_tf_tree rqt_tf_tree
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744859359676-9b788522-cd5e-41d9-9cb3-699142eb2ede.png)

打开规划器代码，搜索base_link，修改为tianracer/base_link，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744860067323-036fe622-01d2-4b78-9bcb-f24dd840a5bc.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744860238231-003f92fe-f5ea-4abc-a39e-1fdbf02a2fd7.png)

```cpp
roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch
rosrun tianracer_gazebo judge_system_node.py
```

```cpp
#include "my_planner.h"
#include <pluginlib/class_list_macros.h>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <tf/transform_datatypes.h>

PLUGINLIB_EXPORT_CLASS(my_planner::MyPlanner, nav_core::BaseLocalPlanner)

namespace my_planner
{
    MyPlanner::MyPlanner()
    {
        setlocale(LC_ALL, "");
    }
    MyPlanner::~MyPlanner()
    {}

    std::vector<geometry_msgs::PoseStamped> global_plan_;  //定义一个全局变量
    tf::TransformListener* tf_listener_; //定义tf监听指针
    costmap_2d::Costmap2DROS* costmap_ros_;  //定义代价地图指针全局变量
    void MyPlanner::initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)
    {
        ROS_WARN("该我上场表演了！");
        tf_listener_ = new tf::TransformListener();  //生成tf工具对象
        costmap_ros_ = costmap_ros;  //将代价地图指针保存到全局变量
    }
    int target_index_;  //定义全局标记变量
    bool pose_adjusting_;
    bool goal_reached_;
    bool MyPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& plan)
    {
        target_index_ = 0;
        pose_adjusting_ = false;
        global_plan_ = plan;  //在setPlan()函数里赋值全局变量global_plan_
        goal_reached_ = false;
        return true;
    }
    bool MyPlanner::computeVelocityCommands(geometry_msgs::Twist& cmd_vel)
    {
        // 获取代价地图的数据
        costmap_2d::Costmap2D* costmap = costmap_ros_->getCostmap();
        unsigned char* map_data = costmap->getCharMap();
        unsigned int size_x = costmap->getSizeInCellsX();
        unsigned int size_y = costmap->getSizeInCellsY();

        // 使用OpenCV绘制代价地图
        cv::Mat map_image(size_y, size_x, CV_8UC3, cv::Scalar(128,128,128));
        for(unsigned int y = 0; y < size_y; y++)
        {
            for(unsigned int x = 0; x < size_x; x++)
            {
                int map_index = y * size_x + x;
                unsigned char cost = map_data[map_index];                 //从代价地图数据取值
                cv::Vec3b& pixel = map_image.at<cv::Vec3b>(map_index);    //获取彩图对应像素地址

                if(cost == 0)    //可通行区域
                    pixel = cv::Vec3b(128, 128, 128);   //灰色
                else if(cost == 254)   //障碍物
                    pixel = cv::Vec3b(0, 0, 0);         //黑色
                else if(cost == 253)   //禁行区域
                    pixel = cv::Vec3b(255, 255, 0);     //浅蓝色
                else
                {
                    // 根据灰度值显示从红色到蓝色的渐变
                    unsigned char blue = 255 - cost;
                    unsigned char red = cost;
                    pixel = cv::Vec3b(blue, 0, red);
                }
            }
        }

        // 在代价地图上遍历导航路径点
        for(int i=0; i < global_plan_.size(); i++)
        {
            geometry_msgs::PoseStamped pose_odom;
            global_plan_[i].header.stamp = ros::Time(0);
            tf_listener_->transformPose("tianracer/odom", global_plan_[i], pose_odom);
            double odom_x = pose_odom.pose.position.x;
            double odom_y = pose_odom.pose.position.y;

            double origin_x = costmap->getOriginX();
            double origin_y = costmap->getOriginY();
            double local_x = odom_x - origin_x;
            double local_y = odom_y - origin_y;
            int x = local_x / costmap->getResolution();
            int y = local_y / costmap->getResolution();
            cv::circle(map_image, cv::Point(x,y), 0, cv::Scalar(255, 0, 255));  //导航路径点

            // 检测前方路径点是否在禁行区域或者障碍物里
            if(i >= target_index_ && i < target_index_ + 10)
            {
                cv::circle(map_image, cv::Point(x,y), 0, cv::Scalar(0, 255, 255)); //检测路径点
                int map_index = y * size_x + x;
                unsigned char cost = map_data[map_index];
                if(cost > 253)
                    return false;   //激活全局规划器
            }

        }

        map_image.at<cv::Vec3b>(size_y/2, size_x/2) = cv::Vec3b(0, 255, 0);  //机器人位置

        // 翻转地图
        cv::Mat flipped_image(size_x, size_y, CV_8UC3, cv::Scalar(128, 128, 128));
        for(unsigned int y = 0; y < size_y; ++y)
        {
            for(unsigned int x = 0; x < size_x; ++x)
            {
                cv::Vec3b& pixel = map_image.at<cv::Vec3b>(y, x);
                flipped_image.at<cv::Vec3b>((size_x - 1 - x),(size_y - 1 - y)) = pixel;
            }
        }
        map_image = flipped_image;

        // 显示代价地图
        // cv::namedWindow("Map");
        // cv::resize(map_image, map_image, cv::Size(size_y*5, size_x*5), 0, 0, cv::INTER_NEAREST);  //尺寸放大5倍
        // cv::resizeWindow("Map", size_y*5, size_x*5);
        // cv::imshow("Map", map_image);

        int final_index = global_plan_.size() - 1;
        geometry_msgs::PoseStamped pose_final;
        global_plan_[final_index].header.stamp = ros::Time(0);
        tf_listener_->transformPose("tianracer/base_link",global_plan_[final_index],pose_final);

        if(pose_adjusting_ == false)
        {
            double dx = pose_final.pose.position.x;
            double dy = pose_final.pose.position.y;
            double dist = std::sqrt(dx*dx + dy*dy);
            if(dist < 0.05)
                pose_adjusting_ = true;
        }
        if(pose_adjusting_ == true)
        {
            double final_yaw = tf::getYaw(pose_final.pose.orientation);
            ROS_WARN("调整最终姿态, final_yaw = %.2f", final_yaw);
            cmd_vel.linear.x = pose_final.pose.position.x * 1.5;
            cmd_vel.angular.z = final_yaw * 0.5;

            if(abs(final_yaw) < 0.1)
            {
                goal_reached_ = true;
                ROS_WARN("到达终点！");
                cmd_vel.linear.x = 0;
                cmd_vel.angular.z = 0;
            }
            return true;
        }


        geometry_msgs::PoseStamped target_pose;
        for(int i=target_index_;i<global_plan_.size();i++)
        {
            geometry_msgs::PoseStamped pose_base;
            global_plan_[i].header.stamp = ros::Time(0);
            tf_listener_->transformPose("tianracer/base_link",global_plan_[i],pose_base);
            double dx = pose_base.pose.position.x;
            double dy = pose_base.pose.position.y;
            double dist = std::sqrt(dx*dx + dy*dy);

            if(dist > 0.2)
            {
                target_pose = pose_base;
                target_index_ = i;
                ROS_WARN("选择第 %d 个路径点作为临时目标，距离=%.2f", target_index_, dist);
                break;
            }

            if(i == global_plan_.size() - 1)
                target_pose = pose_base;
        }
        cmd_vel.linear.x = target_pose.pose.position.x * 1.5;
        cmd_vel.angular.z = target_pose.pose.position.y * 5.0;

        // cmd_vel.linear.x = target_pose.pose.position.x * 1.5;
        // cmd_vel.linear.y = target_pose.pose.position.y * 1.5;  //适应全向移动  旋转速度可以随便设置
        // cmd_vel.angular.z = 1.0;

        //让机器人时刻朝向某个点，这里是示例地图门口
        // cmd_vel.linear.x = target_pose.pose.position.x * 1.5;
        // cmd_vel.linear.y = target_pose.pose.position.y * 1.5;  //适应全向移动  旋转速度可以随便设置
        // geometry_msgs::PoseStamped pose_map, pose_base; //定义两个姿态消息包，一个是门在地图坐标系中的坐标姿态，一个是门在机器人坐标系中的坐标姿态
        // pose_map.pose.position.x = 1.0;
        // pose_map.pose.position.y = -1.5;
        // pose_map.pose.orientation.w = 1.0;
        // pose_map.header.stamp = ros::Time(0);
        // tf_listener_->transformPose("base_link", pose_map, pose_base);
        // cmd_vel.angular.z = pose_base.pose.position.y * 1.0;

        //构建一个600 x 600的opencv图片对象
        cv::Mat plan_image(600, 600, CV_8UC3, cv::Scalar(0, 0, 0));
        for(int i=0;i<global_plan_.size();i++)
        {
            geometry_msgs::PoseStamped pose_base;
            global_plan_[i].header.stamp = ros::Time(0);
            tf_listener_->transformPose("tianracer/base_link",global_plan_[i],pose_base);

            int cv_x = 300 - pose_base.pose.position.y*100;
            int cv_y = 300 - pose_base.pose.position.x*100;
            cv::circle(plan_image, cv::Point(cv_x,cv_y), 1, cv::Scalar(255,0,255));
        }
        cv::circle(plan_image, cv::Point(300,300), 15, cv::Scalar(0, 255, 0));
        cv::line(plan_image, cv::Point(65,300), cv::Point(510,300), cv::Scalar(0, 255, 0), 1);
        cv::line(plan_image, cv::Point(300,45), cv::Point(300,555), cv::Scalar(0, 255, 0), 1);

        // cv::namedWindow("plan"); //把画好路径点的图片显示在这个窗口
        // cv::imshow("plan",plan_image);
        
        // cv::waitKey(1);

        //cmd_vel.angular.z = 1.0;  //机器人旋转速度

        return true;
    }
    bool MyPlanner::isGoalReached()
    {
        // return false;
        return goal_reached_;
    }
    
} // namespace name

```

## 第十二节 针对竞速比赛进行迭代
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744860934303-a910b4a6-ff35-47c7-8685-f30f28e52027.png)

第一，这是一条环形赛道，同时还是一个竞速比赛，所以咱们可以<font style="color:#DF2A3F;">舍弃避障功能</font>，选择纯路线追踪方案，这样可以降低计算量，减少计算时间，提高响应的实时性，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861085358-e856c671-f785-4e7c-8fc3-0e51b08d8b36.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861325486-bf502b5a-e887-441d-8d45-bf9ca79b734d.png)

第二，小车到达这些中间航点时，并不需要调整车体的朝向，那咱们就可以舍弃姿态调整的过程，直接告诉move_base我已经到达，请立刻开始下一段路程的路径规划，

同时，这个到达判断的距离可以放宽些，可以让move_base早一点开始下一段路程的路径规划，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861402796-feb8253a-e5b6-4a3a-a32f-b8b2f7b070e8.png)

第三，整个赛道的跑圈是由直线赛道和弯道组成，所以咱们规划器需要同时适应这两种路况，

在咱们原来的代码中，临时目标点的距离阈值是0.2米，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861540943-f8eca517-8be3-4e14-938a-fd7411170d68.png)，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861614764-3302b9de-477c-44b5-8aad-aa17286203b2.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861698943-a31b14be-185f-4b86-87b3-15abac59b3e3.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744861824664-92aa1cbd-ec61-4a7c-a90c-7db9c2cadeb7.png)

对于直线赛道来说，这个距离阈值取多少都是可以的，最终都是生成向前直行的速度，

所以需要重点考虑的还是弯道如何来处理，最理想的情况是，当小车要入弯的时候，根据距离阈值挑选的路径点，按照咱们的追踪算法，刚好能够走出和全局导航路线一样形状的轨迹，这个跟小车的实际转弯能力和控制算法的参数有关系，如果要做完备的运动学分析，那就比较复杂了，好在咱们用的追踪算法参数并不多，所以可以通过调参的方法，快速的试出一个相对比较实用的参数方案，这里提高了一个比较保守的但是相对比较稳定的参数方案。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744862114520-0383c7a5-2035-48db-9eab-5a65c1fb0352.png)

---

开始按照这个参数方案改进规划器，

咱们使用第八节，没有加入避障功能的规划器进行修改，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744862542758-205f28c8-bd6b-4b6b-bd73-7bd54d70e751.png)

因此需要首先把目标姿态调整、调整结果检查、以及刹车的这部分代码全部去掉，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744862652336-f3f442c7-7fd4-45ee-998d-f6621fd7505d.png)

一旦进入这个1米的判定范围内，立马将到达的标记变量设置为true，告诉move_base，我已经到了，赶紧规划下一段路线吧，这样小车还能维持一定的惯性速度，不至于马上被刹车停住，节奏控制的好的话，可以和下一段导航路线的追踪动作无缝衔接上，中间不出现停车等待的情况，

继续，找到导航路径点追踪的这部分代码，将挑选目标路径点的距离阈值设置为0.8米，然后速度计算的比例系数也需要修改为![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744863717975-2ca3e249-3e26-4705-be9a-ad50aceb724e.png)，

将路线点显示的部分全部注释掉，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744863820254-f2f98b96-8164-4017-943d-2055207ec7e5.png)

这样可以减少一些计算量，降低计算时耗，提高响应速度。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744863990830-64b4461f-bd9e-46b4-bca3-e8282928b8c8.png)

将规划器的控制频率提升到40Hz，也能保证每一次计算速度时，都获得的是新的小车位置，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744864076774-c942464b-8195-461b-b5f7-fd702e6b77cd.png)

同时也能让这个小车位置刷新后，能及时生成新的控制速度，不至于浪费这么高的更新频率，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744864166362-3e5d7cfe-7b0a-44cc-93ae-1fa93443709f.png)

打开这个文件，找到![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744864233253-bea1388a-160e-42a3-b581-5c42ac522deb.png)，

将它的数值修改为40Hz，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744864364658-cafbeb50-9b5c-4bbb-8f6b-87c862c71b78.png)

打开这个文件，找到![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744864406753-51325b46-19ae-458a-9bd3-755c02fbaf99.png)，

这里有两个sleep函数，第一个是小车启动前的延时，给它改成0.3秒，

第二个是小车到达中间航点后开始下一段导航路线规划的延时，给它改成0.02秒，

注意这两个数值别改的太小，否则会出现不规划路线的情况，所以要根据运行效果进行调整，

---

保存，编译，运行，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744871063587-065aea3e-0517-496c-b5ff-605feef8222f.png)

应该是有bug ... ...

## 第十三节 运动过程的PID参数优化
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744871255054-ceafa8f3-7556-4780-a35d-d270d793fa34.png)

找到速度计算部分，在咱们的局部规划器里，是通过追踪特定距离的全局路径点，来实现赛道跑圈的，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744871410180-39b80ded-b5fa-40d1-ac16-623aec8b5d28.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744871586844-09bc005b-7fa1-4a4c-b516-9ebfea0dad8e.png)

速度计算公式是这样的，先对车体建立坐标系，车体向前运动的速度跟路径点在机器人坐标系上的X轴上的距离有关，当车体正对路径目标点时，这个速度最大，当车体偏离路径点方向时，这个速度值会变小，并且因为它偏离了路线方向，造成到达目标路径点的路程是个弧线，比直线路程要长，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744871743768-dcd8f2f2-d7ec-4ae9-8961-0ce5caf9cbcf.png)

如果能尽量减少车头方向偏离路线方向的情况，就能让小车的跑圈速度得到进一步提升。

在现有的比例控制算法下，![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744871937774-e7e9b495-3547-425f-a90c-73d5210d2411.png)

<font style="color:#DF2A3F;">增大比例系数，也可以提高小车的直线运动速度，但是当小车完成一个过弯动作之后，会出现车头方向左右来回摇摆的情况，这个摇摆动作反而可能造成小车跑圈成绩的下降，如何尽可能的抑制这种摇摆动作就成了进一步提升成绩的关键</font>。

下面咱们来使用PID控制来抑制这个车头摇摆的幅度，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744872350462-f9883635-4f56-4a6e-b958-9caa815a7a21.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744872562993-b0643de4-bf0c-44c7-a02f-6f0d6d750c0d.png)

将参数定义在全局开头，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744872671072-17b28e1c-8152-427e-873d-ef7f47ef0c50.png)

---

编译运行，

又是100分，处bug了!!?

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744966851948-200fb233-11b7-4d41-bbce-4d6c102e81f5.png)

<font style="color:#DF2A3F;">发现用的去年国赛的代码，国赛裁判系统更新了，不再是前面85分满分，而是100分满分。</font>

<font style="color:#DF2A3F;">但是这里裁判系统好像有问题，后面去掉插件90秒得分90分... ...</font>

<font style="color:#DF2A3F;">比如：！！！？？？应该是去年为下载了个有bug版本的代码。</font>![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744984028260-11428c9f-cf64-4828-830a-5e8ebffd3a14.png)

## 第十四节 竞速比赛
去年自建比赛地图：原规划器调参

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744966498062-b7549f96-ccbb-425c-a903-12760b81cdb0.png)

```yaml
git clone https://github.com/tianbot/tianracer.git -b dev

echo "source ~/tianbot_ws/devel/setup.bash" --extend >> ~/.bashrc
否则需要每次开启终端中使用source ~/tianbot_ws/devel/setup.bash命令 来配置环境变量   
rostopic echo /tf      rostopic list   rosrun rqt_robot_steering rqt_robot_steering
																					
rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/tianracer/cmd_vel

roslaunch tianracer_gazebo demo_slam_teb_1.launch				
roslaunch tianracer_gazebo tianracer_bringup.launch     
roslaunch tianracer_gazebo tianracer_bringup.launch world:=racetrack_1

roslaunch tianracer_slam tianracer_gmapping.launch        
或者 roslaunch tianracer_slam gazebo_cartographer_2d.launch   
或者 rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/tianracer/cmd_vel

roslaunch tianracer_slam gazebo_map_save.launch           
roslaunch tianracer_slam gazebo_map_save.launch map_file:=my_map
生成目标点文件，roslaunch tianracer_gazebo click_waypoint.launch filename:=test_indoor_points
roslaunch tianracer_gazebo click_waypoint.launch filename:=racetrack_1_points

roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=test_indoor
系统环境变量 export TIANRACER_WORLD=test_indoor
rosrun tianracer_gazebo judge_system_node.py

roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=raicom
系统环境变量 export TIANRACER_WORLD=raicom
rosrun tianracer_gazebo judge_system_node.py

```



### 省赛代码：78.62
#### 原始规划器
![](https://cdn.nlark.com/yuque/0/2025/jpeg/39216292/1744972391123-9a99ae0b-0264-483b-b3df-40a5873983e4.jpeg)



#### 原始规划器调参
```yaml
TebLocalPlannerROS:
  odom_topic: odom

  map_frame: odom


  # Trajectoty 这部分主要是用于调整轨迹

  teb_autosize: True #优化期间允许改变轨迹的时域长度
  # dt_ref: 0.3 #期望的轨迹时间分辨率
  dt_ref: 0.3
  # dt_hysteresis: 0.03 #根据当前时间分辨率自动调整大小的滞后现象，通常约为。建议使用dt ref的10%
  dt_hysteresis: 0.03

  #覆盖全局规划器提供的局部子目标的方向;规划局部路径时会覆盖掉全局路径点的方位角,
  #对于车辆的2D规划,可以设置为False,可实现对全局路径的更好跟踪。
  # global_plan_overwrite_orientation: True
  global_plan_overwrite_orientation: True

  #指定考虑优化的全局计划子集的最大长度,如果为0或负数：禁用；长度也受本地Costmap大小的限制
  # max_global_plan_lookahead_dist: 3.0
  max_global_plan_lookahead_dist: 2.0

  feasibility_check_no_poses: 2 #检测位姿可到达的时间间隔，default：4

  #如果为true，则在目标落后于起点的情况下，可以使用向后运动来初始化基础轨迹
  #(仅在机器人配备了后部传感器的情况下才建议这样做）
  allow_init_with_backwards_motion: False

  global_plan_viapoint_sep: -1

  #参数在TebLocalPlannerROS::pruneGlobalPlan()函数中被使用
  #该参数决定了从机器人当前位置的后面一定距离开始裁剪
  #就是把机器人走过的全局路线给裁剪掉，因为已经过去了没有比较再参与计算后面的局部规划
  global_plan_prune_distance: 1

  exact_arc_length: False
  publish_feedback: False

  # Robot
  # max_vel_x: 1.8
  # max_vel_x: 2.1
  max_vel_x: 5.0
  max_vel_x_backwards: 1
  # max_vel_theta: 3.6
  # max_vel_theta: 3.8
  # max_vel_theta: 10.0
  max_vel_theta: 5.0
  # acc_lim_x: 1.8
  # acc_lim_x: 2.1
  acc_lim_x: 5.0
  # acc_lim_theta: 3.6
  # acc_lim_theta: 3.8
  acc_lim_theta: 5.0

  #仅适用于全向轮
  # max_vel_y (double, default: 0.0)
  # acc_lim_y (double, default: 0.5)

  # ********************** Carlike robot parameters ********************
  # min_turning_radius: 0.5 # 最小转弯半径 注意车辆运动学中心是后轮中点
  # min_turning_radius: 0.6
  min_turning_radius: 0.5
  wheelbase: 0.26 # 即前后轮距离

  #设置为true时，ROS话题（rostopic） cmd_vel/angular/z 内的数据是舵机角度，
  cmd_angle_instead_rotvel: True
  # ********************************************************************

  # footprint_model: # types: "point", "circular", "two_circles", "line", "polygon" 多边形勿重复第一个顶点，会自动闭合
  #   type: "line"
  #   # radius: 0.2 # for type "circular"
  #   line_start: [-0.13, 0.0] # for type "line"
  #   line_end: [0.13, 0.0] # for type "line"
  # front_offset: 0.2 # for type "two_circles"
  # front_radius: 0.2 # for type "two_circles"
  # rear_offset: 0.2 # for type "two_circles"
  # rear_radius: 0.2 # for type "two_circles"
  # vertices: [ [0.25, -0.05], [0.18, -0.05], [0.18, -0.18], [-0.19, -0.18], [-0.25, 0], [-0.19, 0.18], [0.18, 0.18], [0.18, 0.05], [0.25, 0.05] ] # for type "polygon"

  # GoalTolerance
  footprint_model:
    type: "polygon"
    vertices: [[0.18, 0.10], [0.18, -0.10], [-0.18, -0.10], [-0.18, 0.10]]

  # xy_goal_tolerance: 0.1
  # yaw_goal_tolerance: 0.1
  xy_goal_tolerance: 1
  yaw_goal_tolerance: 1
  #自由目标速度。设为False时，车辆到达终点时的目标速度为0。
  #TEB是时间最优规划器。缺少目标速度约束将导致车辆“全速冲线”
  # free_goal_vel: True
  free_goal_vel: False

  # complete_global_plan: True
  # Obstacles

  min_obstacle_dist: 0.2 # 与障碍的最小期望距离,
  include_costmap_obstacles: True #应否考虑到局部costmap的障碍设置为True后才能规避实时探测到的、建图时不存在的障碍物。
  costmap_obstacles_behind_robot_dist: 2.0 #考虑后面n米内的障碍物2.0
  obstacle_poses_affected: 30 #为了保持距离，每个障碍物位置都与轨道上最近的位置相连。

  ## Costmap converter plugin   增加
  #costmap_converter_plugin: "costmap_converter::CostmapToPolygonsDBSMCCH"
  # costmap_converter_plugin: "costmap_converter::CostmapToLinesDBSRANSAC"
  #costmap_converter_plugin: "costmap_converter::CostmapToLinesDBSMCCH"
  #costmap_converter_plugin: "costmap_converter::CostmapToPolygonsDBSConcaveHull"
  #costmap_converter_plugin: "" # deactivate plugin

  costmap_converter_spin_thread: True
  costmap_converter_rate: 5

# 武汉科技大学  队伍名称：Tang-Sun  拍摄日期：2024，6.29
  # Optimization
  weight_viapoint: 1.2
  weight_adapt_factor: 2.0
  obstale_cost_exponent: 1.0

  # no_inner_iterations: 3
  # no_outer_iterations: 2
  no_inner_iterations: 5
  no_outer_iterations: 4
  optimization_activate: True
  optimization_verbose: False
  penalty_epsilon: 0.1
  # weight_max_vel_x: 2
  # weight_max_vel_x: 4
  weight_max_vel_x: 2.5
  weight_max_vel_y: 0.1
  # weight_max_vel_theta: 2
  # weight_max_vel_theta: 8
  weight_max_vel_theta: 2.5
  # weight_acc_lim_x: 2
  # weight_acc_lim_x: 1.9
  weight_acc_lim_x: 2.5
  weight_acc_lim_y: 0.1
  # weight_acc_lim_theta: 2 #1
  weight_acc_lim_theta: 2.5
  weight_kinematics_nh: 100
  weight_kinematics_forward_drive: 100 #1
  weight_kinematics_turning_radius: 100 #1
  # weight_optimaltime: 0.5
  weight_optimaltime: 4
  weight_shortest_path: 0
  # weight_obstacle: 10 #50
  # weight_obstacle: 15
  weight_obstacle: 19
  weight_inflation: 1
  weight_dynamic_obstacle: 1 # not in use yet
  # alternative_time_cost: False # not in use yet
  selection_alternative_time_cost: True
  switching_blocking_period: 0.1

  # Homotopy Class Planner

  enable_homotopy_class_planning: False
  enable_multithreading: False
  simple_exploration: False
  max_number_classes: 4
  roadmap_graph_no_samples: 15
  roadmap_graph_area_width: 5
  h_signature_prescaler: 0.5
  h_signature_threshold: 0.1
  obstacle_keypoint_offset: 0.1
  obstacle_heading_threshold: 0.45
  visualize_hc_graph: False

  # # Recovery  默认注释

  # shrink_horizon_backup: True
  # shrink_horizon_min_duration: 10
  # oscillation_recovery: True
  # oscillation_v_eps: 0.1
  # oscillation_omega_eps: 0.1
  # oscillation_recovery_min_duration: 10
  # oscillation_filter_duration: 10

  # 多线规划
  # enable_homotopy_class_planning: True # 激活多线规划
  # enable_multithreading: True          # 多线程计算
  # max_number_classes: 2                # 规划的路径线数上限
  # selection_cost_hysteresis: 1.0       # 路径轨迹入选的评价上限
  # selection_obst_cost_scale: 1.0       # 障碍物评价在入选标准中的缩放倍率
  # selection_alternative_time_cost: False # 时间成本是否要进行平方计算
  # roadmap_graph_no_samples: 15         # 为创建 roadmap graph 而生成的样本数
  # roadmap_graph_area_width: 5          # 关键点采样的宽度，单位为米。
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744967078731-0ffe1b90-c40b-4463-9d83-c5d01b5c1331.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744967470530-125d4f82-d180-414e-94f3-0a0b32be72db.png)

#### 自制局部规划器+原始参数
略。原始代码更新了，没备份找不到了。

#### 自制局部规划器+去年调参
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744968500044-18e07a1f-a2fc-4f3a-a392-c29ac357bd69.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744966650147-1004501a-9a2e-4ed5-aa56-5530ba7d6708.png)



### 国赛代码：
#### 原始代码
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744980752748-250ed37b-8f32-406c-aa86-a1b2736cb584.png)



#### 自制规划器
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744980293751-08cfd42b-7b0c-4610-a83e-72a338695880.png)



### 新下载tianracer-dev
#### 原始代码
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744982787919-e2ecf46e-e1d3-44c9-acae-ce3239e048e9.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744981617969-fbbdadc8-62b4-48d4-8e76-abbc88a777ca.png)

#### 自制规划器
总是发生碰撞。

### 2025年睿抗省赛
#### 基本环境
```yaml
git clone https://github.com/tianbot/tianracer.git -b dev
仿真 roslaunch tianracer_gazebo tianracer_bringup.launch world:=racetrack_1
仿真+导航 roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=racetrack_1
系统环境变量 export TIANRACER_WORLD=racetrack_1
rosrun tianracer_gazebo judge_system_node.py
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748165556189-2c57af82-c680-4743-92a4-6846c21a9d10.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748165515893-b481db04-a43b-4e59-b72a-44b97b2141c4.png)



![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748165821890-82a00146-e8a6-4220-b162-0946a56c407b.png)

默认使用的mutil_goals.py，多点巡航方式进行路径规划。



#### 减小休眠时间
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748166840471-9e1dc41a-8afb-4eca-bdae-eacfc8e233ce.png)

发现小车到新的导航点时都会停顿一会，

这里有两个sleep函数，第一个是小车启动前的延时t1，

第二个是小车到达中间航点后开始下一段导航路线规划的延时t2，

注意这两个数值别改的太小，否则会出现不规划路线的情况，所以要根据运行效果进行调整。

##### 调整1：t1=1.0 , t2=0.001
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748167783595-257538ef-d27c-43de-b025-5840e985d2eb.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748167741754-69e30e8c-ddf8-44d3-a22d-248b4076061d.png)

##### 调整2：t1=0.3 , t2=0.02
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748167010944-615de272-23d6-4c3d-a583-c4b0684eeaf1.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748167299448-05111e81-fbbf-4c4a-8f49-306d8ed0e926.png)



#### 提升规划器控制频率
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748167521173-216248eb-96ec-44bc-b84c-21fb49498118.png)

将规划器的控制频率提升到40Hz，也能保证每一次计算速度时，都获得的是新的小车位置，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1744864076774-c942464b-8195-461b-b5f7-fd702e6b77cd.png)

同时也能让这个小车位置刷新后，能及时生成新的控制速度，不至于浪费这么高的更新频率。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748168299433-1a619423-fc3a-4351-86ac-718df2228608.png)

#### 自制局部规划器
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748168579029-36cf42fa-fa61-4192-ae11-ef151355ebbe.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748168990778-02106e41-fae8-49b4-9673-3a899e03e453.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748169011170-df74e28a-2701-4770-b4ea-ea3752ad3477.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748168972603-7b53120a-80d1-4e6e-826b-4547c70e711c.png)

<font style="color:#DF2A3F;">发现在这里卡住不动！</font>

将t2的0.001改为0.02，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748169182997-3ac4f9d9-8d7f-43a1-bd13-de2131f6f4e6.png)

没有效果，还是在同样位置卡住。

t1=0.3 , t2=0.1  卡住，

原始默认参数 t1=2.0, t2=1.0   卡住。

<font style="color:#DF2A3F;">根据网友提示，重新标记导航点</font>，

```yaml
roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=racetrack_1
export TIANRACER_WORLD=racetrack_1
rosrun tianracer_gazebo judge_system_node.py
```



---

换tianracer_racetrack地图就不会卡住，

```yaml
roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch
rosrun tianracer_gazebo judge_system_node.py
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748170081533-0e8163ee-e3cc-4401-b5e1-454c89e24c98.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748170455246-fbbd9a9d-cae1-4d7f-ad45-f305deb7df7e.png)

```yaml
roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=raicom
export TIANRACER_WORLD=raicom
rosrun tianracer_gazebo judge_system_node.py
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748412627956-e90aa5ce-a20a-4839-969d-1de0ac84b9e3.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748412603689-ae97777f-b63a-4bab-94b3-ee2e04e3806b.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1748416682457-99708288-bd92-4d5c-8c35-977f1d2fb8eb.png)



#### 调参
```yaml
rosrun rqt_reconfigure rqt_reconfigure 或者 rqt
```



---

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749115473110-cc406909-9d2a-44ef-b72b-3d155ec47190.png)











---

#### 省赛
##### 地图构建
###### 默认仿真环境建图
```plain
roslaunch tianracer_gazebo tianracer_bringup.launch world:=singapore

roslaunch tianracer_slam tianracer_gmapping.launch        
或者 roslaunch tianracer_slam gazebo_cartographer_2d.launch   
rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/tianracer/cmd_vel
速度0.23

保存地图：
roslaunch tianracer_slam gazebo_map_save.launch           
roslaunch tianracer_slam gazebo_map_save.launch map_file:=my_map
```

###### 其他仿真环境建图
```yaml
 roslaunch slam_pkg gmapping.launch
 rosrun teleop_twist_keyboard teleop_twist_keyboard
```

##### 导航点生成
```yaml
生成目标点文件：
roslaunch tianracer_gazebo click_waypoint.launch filename:=singapore_points
ctrl+C保存
```

##### 导航
```plain
roslaunch tianracer_gazebo demo_tianracer_teb_nav.launch world:=singapore
export TIANRACER_WORLD=singapore
rosrun tianracer_gazebo judge_system_node.py
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749792779916-b0c8bc79-b970-4417-821a-e62caa9ccdeb.png)

###### 默认局部规划器
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749791307947-6e3ac7be-5390-4152-92c5-1629e9d574bf.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749791355315-30080311-11c4-4084-9d92-5b8eb8193886.png)

---

###### 继续调参
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750057177748-0aa55357-5ad4-4c44-bb4c-c6addc2fd2f1.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750057254501-1a7bfa95-55dc-4aa9-b1b1-d9de8e254a6a.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750057278151-9ec09094-e109-4036-904d-b3ad1d519446.png)



速度全6.5

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750057732334-6dd5d398-7904-4635-bab2-160c45b73553.png)



速度全6.6，只要不撞雪花筒和卡住停顿，运气好

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750058169191-e5a9edc0-3797-4e67-9318-16299eb3a982.png)



速度全6.7  跑了两次都71.669 比较稳定

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750058541817-28d1de8a-4ebe-4170-9824-debd5e0efc8b.png)



速度6.6，优化权重4.6，障碍物时常停顿

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750059970907-14a8f365-3d76-46c0-be17-87dc60871228.png)

速度6.6，优化权重给4.8，可能会卡住不动不继续规划路线

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750059193343-c6f59f26-d5b7-4682-87d8-e12211deb068.png)



速度权重全给4

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750060666141-6e02b912-e378-4778-9e02-c8a1178adca2.png)





---

<font style="color:#DF2A3F;">72</font>

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750170742336-90d5203c-fd44-4510-b326-d2d008639e94.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750170765842-5b55ee1f-79c7-4e85-b676-17d96ac3a8a3.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750170710614-5829ca65-d902-4126-ba68-065929ea1910.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750171243101-fb9cd33e-35d3-453b-b612-6653de9fc6ca.png)





![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750171543195-1179189d-cb08-4379-a3c4-f69a52afd17a.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750171446765-4e621834-a2d2-4ed4-a142-103c4977ecde.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750171519049-358f2287-fa35-44fc-b494-ea602f7b3f88.png)



---

<font style="color:#DF2A3F;">73</font>

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750246396656-ae951ea4-0682-4d51-b449-f3687776f2c6.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750246417198-ce727921-9675-44b5-9cb4-ba8322ebee3e.png)

<font style="color:#DF2A3F;"></font>

<font style="color:#DF2A3F;"></font>

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750246715265-cf80e19b-cb3d-4ae4-9b23-8f7451944596.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750246702907-86ea0040-3b32-4929-bb4d-c08d5cefd86f.png)

<font style="color:#DF2A3F;"></font>

<font style="color:#DF2A3F;"></font>

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750247246584-6a705ebf-a3cc-4ddf-a2f1-27587592766d.png)![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750247262484-41e2fb18-7f98-42fe-bc32-19eaa7f50db3.png)

<font style="color:#DF2A3F;"></font>

---

###### 录屏
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750062302187-5617ae1c-db22-4276-b1a5-9dc11188686f.png)

---

新参数

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1750247572089-9e82a000-f510-420d-bf9e-fb4bc8f124ea.png)



###### 自制作局部规划器
速度系数3.5

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749791727106-70c361fe-711c-4707-b855-8edfc66963da.png)



速度系数3.8

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749791928617-c911194f-412b-49be-8b8e-68605966072e.png)



速度系数4.2

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749792121142-eb3af065-810a-4d57-a83b-00b6d79090ba.png)



速度系数4.5

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749792412257-0ab5bd28-30ac-4cba-8f89-85009ad8ecce.png)





---

##### cartographer建图与导航
<font style="color:#DF2A3F;">下面试一下cartographer建图</font>，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749819913600-98874ccd-312b-42a1-bc12-9a13de02c4d5.png)

启动，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749820328114-51e34a49-8f55-477f-88cd-b8f1fa4a473a.png)

使用cartographer建的地图需要对地图进行一些修改:

建好的这个.pgm地图文件需要进行一下旋转，可以使用gimp软件编辑一下。（以小车位置为中心，逆时针旋转90度）。然后调整与.pgm文件对应的.yaml文件中的origin [ x，y，yaw（弧度制） ]这个参数组，从左至右，参考原点为地图坐标原点，即初始启动时小车的位置。

```plain
sudo apt install gimp
```

按原点（估计一下）旋转-90度，然后扩大图层，接着适配画布，

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749823339129-a3288332-7eff-4c6b-b64c-1211029c2d7e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749823483545-616487aa-c8f4-4ed8-aea8-a804e911c844.png)

需要平移或者修改配置文件为新原点。

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749823655885-7f1954c6-aff9-483d-ae23-1a088e1892cc.png)

###### 尝试
```plain
image: /home/teng/tianracer_ws/src/tianracer/tianracer_gazebo/maps/singapore.pgm
resolution: 0.025000
#origin: [-9.951628, -1.905597, 0.000000]
origin: [-5, 0, 0.000000]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749823892464-9a395a46-9f97-48a2-b6b0-6f51ef70b660.png)

发现越大(正）越左越下，

```plain
image: /home/teng/tianracer_ws/src/tianracer/tianracer_gazebo/maps/singapore.pgm
resolution: 0.025000
#origin: [-9.951628, -1.905597, 0.000000]
origin: [-15, -10, 0.000000]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749824131269-9fb95d40-f6c0-465a-9966-019a7a4e7d45.png)



```plain
image: /home/teng/tianracer_ws/src/tianracer/tianracer_gazebo/maps/singapore.pgm
resolution: 0.025000
#origin: [-9.951628, -1.905597, 0.000000]
origin: [-35, -24, 0.000000]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749824485819-51f7bbf0-3fbd-4a30-8cc1-35d511893883.png)



```plain
image: /home/teng/tianracer_ws/src/tianracer/tianracer_gazebo/maps/singapore.pgm
resolution: 0.025000
#origin: [-9.951628, -1.905597, 0.000000]
origin: [-38, -24, 0.000000]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749824820195-6ba48d0b-c95a-44b1-b55f-edcf21900630.png)



###### over
```plain
image: /home/teng/tianracer_ws/src/tianracer/tianracer_gazebo/maps/singapore.pgm
resolution: 0.025000
#origin: [-9.951628, -1.905597, 0.000000]
origin: [-38.5, -25, 0.000000]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
```

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749825086446-be918e78-b992-4e90-ad03-152f2e2fe242.png)

还是有点歪，看来是旋转没旋转好。

<font style="color:#DF2A3F;">标导航点（可能不会即时运动），然后运行，</font>

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749825719881-ac756e5e-9e44-4590-afe3-6784131f75b9.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749825793692-d2278252-3c5c-462e-a536-d624718fc496.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749826055480-716cb980-43af-4c9e-9176-7d8c0823b8fc.png)



---

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749829134824-843b492f-5ad8-4e58-8e25-e42ad5efef7e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1749828673250-154aa658-b78b-4895-891d-a513bf6b8d71.png)



