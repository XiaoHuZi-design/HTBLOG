---
title: "QT版本欢乐斗地主"
date: 2026-01-25
tags: ["C++", "Qt", "游戏", "斗地主"]
---

## 引言
码云：[https://gitee.com/subingwen/landlords](https://gitee.com/subingwen/landlords)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756542150420-101838e2-ebb3-44a5-9827-475d664fed11.png)

---

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756557095659-5a16f8d5-9fd9-4546-9c1a-cf7f0e973e17.png)

完成整个项目开发需要编写19个类。

[斗地主.xmind](https://www.yuque.com/attachments/yuque/0/2025/xmind/39216292/1757339651989-2ab0f15d-6a64-44c5-beac-733adf61b774.xmind)  [斗地主-思维导图.pdf](https://www.yuque.com/attachments/yuque/0/2025/pdf/39216292/1757339669429-ed01c47c-2be1-40ee-aa73-2433fafeb07f.pdf)

[斗地主-流程图.pdf](https://www.yuque.com/attachments/yuque/0/2025/pdf/39216292/1757339676018-9aa79d4e-e137-4e40-998a-3ed696e43092.pdf)

---

# 第一阶段：模块开发
## 一、**创建一个新项目**
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756557730244-f3516c0c-5a4e-4637-8fa5-a73f462c0764.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756557855224-c1bda0b5-6f40-482b-9fa3-6d7b40f60592.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756557901972-7aa65ed1-4ef9-44d1-be30-90c39997db2a.png)

## 二、添加一个卡牌类
鼠标右键项目名，Add New添加一个C++类

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756558193258-5f9005c8-290e-4516-8886-c322e70c58f3.png)

创建好后，首先需要再卡牌类里面添加两个枚举：卡牌花色和卡牌点数

```cpp
#ifndef CARD_H
#define CARD_H


class Card
{
public:
    // 花色
    enum CardSuit
    {
        Suit_Begin,
        Diamond, //方块
        Club, //梅花
        Heart, //红桃
        Spade, //黑桃
        Suit_End
    };
    // 点数
    enum CardPoint
    {
        Card_Begin,
        Card_3,
        Card_4,
        Card_5,
        Card_6,
        Card_7,
        Card_8,
        Card_9,
        Card_10,
        Card_J,
        Card_Q,
        Card_K,
        Card_A,
        Card_2,
        Card_SJ, //small joker
        Card_BJ, //big joker
        Card_End
    };

    //花色类型和点数类型的成员变量
    CardSuit suit;
    CardPoint point;
    Card();
};

#endif // CARD_H

```

由于C++里面的类一般情况下咱们都需要把它的成员变量定义为私有，这里就重新修改一下权限，

```cpp
private:
    //花色类型和点数类型的成员变量
    CardSuit suit;
    CardPoint point;
```

定义为私有后，咱们就不能在外部访问了，为了能够访问到这个属性咱们就得添加相关的成员函数，通过成员函数再间接的对成员变量进行读或者写操作，

```cpp
    //成员函数
    void setSuit(CardSuit suit); //设置花色
    void setPoint(CardPoint point); //设置点数
    void suit(); //获取花色
    void point(); //获取点数

private:
    //花色类型和点数类型的成员变量
    CardSuit m_suit;
    CardPoint m_point;
```

下面再来实现定义的这四个函数，

```cpp
    CardSuit suit() const;   //获取花色 末尾加const限定 便于const类型调用
    CardPoint point() const; //获取点数 末尾加const限定 便于const类型调用
```

```cpp
void Card::setSuit(CardSuit suit)//设置花色
{
    m_suit = suit;
}
void Card::setPoint(CardPoint point) //设置点数
{
    m_point = point;
}
Card::CardSuit Card::suit() const//获取花色
{
    return m_suit;
}
Card::CardPoint Card::point() const //获取点数
{
    return m_point;
}

```

## 三、添加卡牌窗口类
QWidget

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756560669780-12ee650b-d709-4813-9afc-937a783e81da.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756610191524-f6389c9b-1a83-4935-845e-479a4455aeb9.png)

首先每张扑克牌窗口对象上都需要显示对应的图片，所以需要一个设置图片的函数，包含正面图片和背面图片，

```cpp
#ifndef CARDPANEL_H
#define CARDPANEL_H

#include <QObject>
#include <QWidget>

class CardPanel : public QWidget
{
    Q_OBJECT
public:
    explicit CardPanel(QWidget *parent = nullptr);

    // 设置获取图片函数
    void setImage(QPixmap &front, QPixmap &back); //设置图片正面和背面
    QPixmap getImage(); //获取图片

private:
    void paintEvent(QPaintEvent *event);  //事件处理函数

signals:

private:
    //添加两个私有成员变量
    QPixmap m_front;
    QPixmap m_back;

};

#endif // CARDPANEL_H

```

下面开始编写者成员函数，

```cpp
void CardPanel::setImage(QPixmap &front, QPixmap &back)
{
    m_front = front;
    m_back = back;
}


QPixmap CardPanel::getImage() //获取图片
{
    return m_front; //返回正面
}

void CardPanel::paintEvent(QPaintEvent *event) //事件处理函数
{

}
```

在添加一个成员变量布尔值来判断窗口是正面还是背面，

```cpp
    //添加一个布尔值标记是哪一面
    bool m_isfront;
```

如果是正面就绘制正面图片，如果是背面，就绘制背面图片，

```cpp
#include <QPainter>  //添加画图

void CardPanel::paintEvent(QPaintEvent *event) //事件处理函数
{
    QPainter p(this); //当前窗口
    if(m_isfront)
    {
        p.drawPixmap(rect(), m_front); //rect()获取当前窗口尺寸信息
    }
    else
    {
        p.drawPixmap(rect(), m_back);
    }
}
```

paintEvent函数什么时候被调用？当我们把图片设置好之后就需要重新绘制当前图片信息，因此需要手动进行<font style="color:#DF2A3F;">update更新</font>，另外需要让当前窗口和咱们的扑克牌对象的图片一样大，咱们随便使用一个m_front就能获取扑克牌的尺寸信息，

```cpp
void CardPanel::setImage(QPixmap &front, QPixmap &back)
{
    m_front = front;
    m_back = back;
    //获取图片的尺寸信息
    setFixedSize(m_front.size());

    update(); //手动更新
}
```

除此之外，我们还需要再当前的扑克牌窗口类里面，添加两组有关状态的属性函数，

一组用来标记<font style="color:#DF2A3F;">当前的扑克牌窗口到底是正面还是背面</font>，另一组是用来标记当前的扑克牌窗口有没有被选中，

```cpp
    // 扑克牌显示哪一面
    void setFrontSide(bool flag); //将flag值通过m_isfront保存下来
    bool isFrontSide(); //判断当前扑克牌到底是正面还是背面
```

```cpp
void CardPanel::setFrontSide(bool flag) //将flag值通过m_isfront保存下来
{
    m_isfront = flag;
}

bool CardPanel::isFrontSide() //判断当前扑克牌到底是正面还是背面
{
    return m_isfront;
}
```

<font style="color:#DF2A3F;">接着添加窗口是否被选中，</font>

```cpp
    // 记录窗口是否被选中了
    void setSelected(bool flag);
    bool isSelected();
```

```cpp
void CardPanel::setSelected(bool flag)
{
    m_isSelect = flag;
}

bool CardPanel::isSelected()
{
    return m_isSelect;
}
```

<font style="color:#DF2A3F;">另外扑克牌窗口里面要显示正面图片对应的花色以及他的点数，</font>

所以需要包含前面定义的卡牌类，

```cpp
#include <card.h> //包含卡牌类
```

```cpp
    // 扑克牌的花色以及点数
    void setCard(Card& card);
    Card getCard();
```

```cpp
void CardPanel::setCard(Card &card)
{
    m_card = card;
}

Card CardPanel::getCard()
{
    return m_card;
}
```

然后还需要知道这张扑克牌的所有者，到底属于左侧机器人还是右侧机器人或者当前玩家，

因此需要先创建玩家类Player。

## 四、添加玩家类
基类选择QObject，因为后续可能在这个类里面使用QT的信号槽机制，需要让这个类从QObject直接或者间接派生，也就是直接继承QObject或者从QObject的子类派生继承，如果不继承QObject，那么咱们就没有办法使用QT给提供的信号槽机制，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756605632419-a50c082c-36af-487a-8d46-dc9ad27dc465.png)

在前面卡牌窗口类添加

```cpp
#include <player.h> //包含玩家类
```

并添加卡牌所有者玩家设置函数，

```cpp
    // 扑克牌的所有者 到底属于左侧机器人还是右侧机器人或者玩家
    void setOwner(Player* player);  //玩家设置函数
    Player* getOwner();
```

```cpp
void CardPanel::setOwner(Player *player)
{
    m_owner = player;
}

Player *CardPanel::getOwner()
{
    return m_owner;
}

```

然后添加鼠标事件处理函数，

```cpp
void mousePressEvent(QMouseEvent* event); //鼠标事件处理函数
```

具体逻辑暂时空着，当要用到鼠标事件的时候再添加。

## 五、添加多种卡牌类
在游戏开始阶段，每副扑克牌有52张，每次需要依次分发给三个玩家，每个玩家拿一个碗进行存储，最后抢到地主的玩家会得到最后三张底牌，

在游戏进行阶段，每个玩家依次出牌，有可能打出的是一张，有可能是多张出牌，打出一张或多张手里就少一张或多张，直到手里牌打完了，这个玩家就赢了，

这就是游戏的基本规则。

也就是咱们需要有一个类对这多张扑克牌进行管理，首先在管理扑克牌的类里就需要有一个容器来存储这多张扑克牌，而且这个扑克牌的数量是实时在发送变化的，所以这个<font style="color:#DF2A3F;">存储数据的容器是要能够动态变化</font>的，如果基于C语言，最简单的方法就是用数组或者说自己写个链表，但是在C++里面，咱们就可以使用STL里面的容器了，标准C++给我们提供了一系列的容器，在QT里面，也给我们提供了一系列的STL的容器，QT里面的STL只是对标准的C++的STL有一些封装而已。

我们如果想要使用STL里面的容器，咱们用什么？

首先我们手里的每张牌不一样（即使点数一样，花色也不一样），在STL里面有个容器，它可以存储若干个元素，但是它能保证元素不重复，就是set容器，也就是集合，在标准C++里面，这个集合里面的元素，它是有序的（自动排序，默认情况从小到大），但是在QT里面的这个容器，它只能保证存储的元素是不重复的，但是里面的数据是无序的，因为在STL里面这个set容器，它是用红黑树来实现的，在QT里面，这个函数的底层是使用哈希表来实现的，因此实现的方式不一样最终呈现的结果不一样。

注：<font style="color:rgb(0, 0, 0);">红黑树是一种特殊的二叉查找树，它在每个节点上增加了一个存储位表示节点的颜色（红色或黑色）。通过约束节点的着色方式，确保没有任何一条路径会比其他路径长出两倍，从而维持近似的平衡。</font>

<font style="color:#DF2A3F;">如果使用QT这边的容器，需要自己完成相关排序操作</font><font style="color:rgb(0, 0, 0);">，</font>

另外，当我们有了这个容器之后，发牌阶段，咱们就需要把得到的扑克牌，依次存储到这个set容器里面，当出牌的时候，咱们就需要把一张或者多张从set容器里面删除，并且咱们扑克牌拿在手上还需要展示到当前窗口并按照某种顺序排列，一般从小到大进行排列，需要知道最大点数和最小点数，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756610123754-9da551eb-48a5-481e-b2a6-20b67b7bafe5.png)

添加一个新的多张卡牌类，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756610289570-d892b0c2-a896-4d91-97e3-bd153e5c0376.png)

因为这个Cards类主要是存储扑克牌相关的属性信息，因此目前可以不需要指定基类。



首先添加一个容器类型的私有成员变量，存储扑克牌的数据，

```cpp
#include "card.h"
#include <QSet>

private:
    QSet<Card> m_cards;
```

发牌--》存储，出牌---》删除

因此需要添加扑克牌添加与删除函数，

```cpp
    //添加扑克牌
    void add(Card& card);
    void add(Cards& cards);
    //删除扑克牌
    void remove(Card& card);
    void remove(Cards& cards);
```

如果说我们得到一个card对象，就需要把它放进m_cards里面，

查询一下QSet这个类给我们提供了哪些函数，直接F1跳转到帮助文档QSet处，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756995894018-867576af-e9ac-4a0b-a587-3e87c670e199.png)

找到有个insert方法，

```cpp
void Cards::add(Card &card)
{
    m_cards.insert(card);
}
```

如果拿到多张扑克牌对象，则需要把N1张和N2张合并，也就是求集合N1和集合N2的并集，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756996256321-4e7db116-87d3-4f18-913e-0cd469b9bb81.png)

找到求并集的函数，参数为QSet类型，

```cpp
void Cards::add(Cards &cards)
{
    m_cards.unite(cards.m_cards);
}
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756996679390-3e768381-969b-4c86-986f-0eb2429210d5.png)  删除

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1756996666752-3c8f420b-fb06-4f3e-a0f7-59b645ad1eaf.png) 差集

```cpp
void Cards::remove(Card &card)
{
    m_cards.remove(card);
}
void Cards::remove(Cards &cards)
{
    m_cards.subtract(cards.m_cards);
}
```

上面两个add方法，没调用一次只能添加一个对象（单张扑克牌对象和多张扑克牌对象），但是添加多张扑克牌对象我们不能直接进行操作，要做一下前期的铺垫，需要先对Cards类型作初始化，如果网Cards里添加10张扑克牌就需要调用10次add单张方法，然后得到Cards对象，在调用add多张方法对两个集合进行加法操作。

有没有一种简单的方式，可以让我们一次性就把这多张单个的扑克牌对象放到cards里？可以参考C++里面的输出操作，如果说要把一个数据打印到当前终端，在标准C++里面使用的是Cout，通过插入数据符号就可以把多条数据放到这个Cout对象里（Cout << xxx << ???）,这个对象就可以把当前数据打印到屏幕上。这个<<在这不是左移符，它和Cout一同使用就是一个数据的插入符，因为在这个对应的i/o类里面对这个操作符进行了重载。那么我们也可以在当前的cards类里面对这个操作符<<进行重载，完成一个数据插入的操作。

```cpp
    //一次性插入多个数据(操作符重载<<)
    Cards& operator << (const Card& card);
    Cards& operator << (const Cards& cards);
```

```cpp
Cards &Cards::operator <<(const Card &card)
{
    add(card);
    return *this;
}
Cards &Cards::operator <<(const Cards &cards)
{
    add(cards);
    return *this;
}
```

另外还需要判断扑克牌的数量，扑克牌是否为空、玩家当前扑克牌数量、以及游戏重新开始清空玩家手里扑克牌，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757058187363-b29d0a11-82e4-4614-ade7-76607149d03d.png)

```cpp
    //扑克牌的数量
    int cardCount();
    //是否为空
    bool isEmpty();
    //清空扑克牌
    void clear();
```

```cpp
int Cards::cardCount()
{
    return m_cards.size();
}

bool Cards::isEmpty()
{
    return m_cards.isEmpty();
}

void Cards::clear()
{
    m_cards.clear();
}
```

接下来看一下这多张扑克牌类里面关于点数相关的一些操作函数，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757058199824-d6ec40b2-c32b-4ca1-9496-b5cc7db5fef9.png)

首先需要知道在多张扑克牌里面点数最小的是谁，点数最大的是哪张，某张扑克牌在当前的这多张集合里面到底是存在还是不存在， 

```cpp
Card::CardPoint Cards::maxPoint()
{
    // 使用迭代器写个for循环
    Card::CardPoint max = Card::Card_Begin; //最大值初始化最小值
    //如果m_cards集合容器是空的就直接返回Card_Begin了，所以做个判断
    if(!m_cards.isEmpty())
    {
        for (auto it = m_cards.begin(); it!=m_cards.end(); ++it)
        {
            if(it->point() > max)
            {
                //更新max值
                max = it->point();
            }
        }
    }
    return max;
}
```

为什么it->可以直接调用point呢？这个需要看一下关于QSet类，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757058817504-a6ea176e-8124-46ea-acce-54477be7849a.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757058869429-cbdf484d-f240-4172-90d3-cb62012114b1.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757060361373-ed75f63f-b8c6-43b8-ad74-7c8f91104954.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757060375975-7faf2226-c493-42b3-a218-cdf25e169f96.png)

可以看到迭代器类型有两个，在这个iterator里面它作了一些重载，我们基于这个迭代器对象使用箭头这个操作符就能够取出容器中对应的那个实例对象T，得到这个对象后，再调用这个对象的api就没有问题了，

也就是说用it->得到的是一个card对象，使用card函数再调用相关的函数就能得到需要的属性了。

```cpp
Card::CardPoint Cards::minPoint()
{
    // 使用迭代器写个for循环
    Card::CardPoint min = Card::Card_End;  //最小值初始化最大值
    //如果m_cards集合容器是空的就直接返回Card_Begin了，所以做个判断
    if(!m_cards.isEmpty())
    {
        for (auto it = m_cards.begin(); it!=m_cards.end(); ++it)
        {
            if(it->point() < min)
            {
                //更新min值
                min = it->point();
            }
        }
    }
    return min;
}
```

```cpp
int Cards::pointCount(Card::CardPoint point)
{
    int count = 0;
    for (auto it = m_cards.begin(); it!=m_cards.end(); ++it)
    {
        //判断当前点数和传进来的点数是否相等
        if(it->point() == point)
        {
            count++;
        }
    }
    return count;
}
```



QSet这个类里面提供了相关函数判断某张牌是不是在这个集合里面，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757060427086-b0f8439e-e1cd-448c-adae-70198af9e391.png)

可以传递一个元素，也可以传递一个集合，存在返回true，不存在返回false,

```cpp
bool Cards::contains(const Card &card)
{
    return m_cards.contains(card);
}

bool Cards::contains(const Cards &cards)
{
    return m_cards.contains(cards.m_cards);
}
```



我们把52张扑克牌都存储在QSet容器里面（无序的），然后发牌阶段每次需要取出一张牌依次分发，

```cpp
#include <QRandomGenerator> //生成随机数
```

F1跳转，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757061167891-028fee2f-2a67-4d4f-ad66-c76f95c073cc.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757061228250-25457394-aef9-4412-8714-c84859e7b90f.png)

两种方法，一种调用构造函数，一种直接调用静态方法，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757061376301-3d3a2f9d-cb75-41cf-8e19-a0524c8f9f5a.png)bounded生成随机数

```cpp
    //随机取出一种扑克牌
    Cards takeRandCard();
```

```cpp
Card Cards::takeRandCard()
{
    //生成一个随机数#include <QRandomGenerator>
    //调用静态方法global得到一个对象，再根据对象调用bounded函数生成随机数 0-51
    int num = QRandomGenerator::global()->bounded(m_cards.size());
    //创建一个迭代器 const_iterator只读迭代器，只取扑克牌不修改
    QSet<Card>::const_iterator it = m_cards.constBegin();
    for(int i=0; i<num; i++, ++it);  //只让它循环就行了
    //循环num次，就把it迭代器指向的元素的值给取出来 Card类型
    Card card = *it;
    //再把迭代器it对应的元素从容器里面删掉
    m_card.erase(it);  //发出去的一张牌给删掉

    return card; //把拿出去的一张牌返回给调用者
}
```



对于玩家扑克牌抽取需要进行排序，因此需要一个可以存储有序序列的容器，对于C++里面是STL的Vector，对于QT里面就是QVector，

```cpp
QVector<Card>
```

由于这个类型比较长，在后续的过程中可能会操作写起来不方便，因此可以给它定义一个别名，可以使用typedefine或者使用using，在card.h里面末尾，

```cpp
#include <QVector>
//定义类型的别名
using CardList = QVector<Card>;
```

后续就使用CardList代替，

```cpp
    // QVector<Card>
    // QSet  -->  QVector  转化
    CardList toCardList(); //将QSet无序数列转换成有序数列并存储到CardList
```

然后排序可以使用升序或者降序，可以再定义一个枚举num类型，

```cpp
public:
    enum SortType{Asc, Desc, NoSort};  //升序、 降序、 不排序
```

然后把SortType作为toCardList函数的参数，

```cpp
CardList toCardList(SortType type);
```

下面来实现一下这个排序，

先变一下这个Set容器，首先把东西取出来，再存储在Vector容器，然后再排序，

```cpp
CardList Cards::toCardList(Cards::SortType type)
{
    CardList list;  //定义一个QVector<card>容器
    for(auto it = m_cards.begin(); it != m_cards.end(); ++it)
    {
        list << *it; //把扑克牌从Qset取出，并存入list
    }
    //排序类型判断
    if (type == Asc)
    {

    }
    if (type == Desc)
    {

    }
}
```

现在的问题就是，我们怎么对CardList里面的元素进行排序·呢？在QT里面其实有一个函数qsort，通过这个函数就可以对容器里面的元素完成排序操作，但是这个qsort在高版本的QT里面被废弃了，官方不建议使用，F1跳转，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757073730542-7ce38e4e-d708-4a5a-8eaa-ff86ebba772a.png)

但是在帮助文档直接搜索可以搜索到，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757073908738-37a4ec86-f9c9-4aff-bdbe-7b56fa04d904.png)

建议使用 标准C++的std::sort 代替，

```cpp
std::sort(list.begin(), list.end(), lessSort);
```

这里添加使用**回调函数**lessSort，利用这个函数判断出这两个元素里面哪个元素比较小，

关于这个lessSort需要传递两个参数，这两个参数都应该是CardLists里面的元素类型（Card）,

因为这个lessSort的参数类型是Card类型，因此建议把这个函数定义到Card.h类里面，这里把改函数写成当前类的外部函数而不是成员函数，

```cpp
//对象比较
bool lessSort(const Card& c1, const Card& c2);
bool greaterSort(const Card& c1, const Card& c2);
```

如果咱们把这个函数写在card类里面，就是当前类里面的对象对当前类里面的成员函数进行操作，或者当前类里面的对象和另外的一个对象进行相关的操作，但是这个lessSort是对指定的两个对象进行相关操作，是c1和c2，和当前这个this的对象没关系，是一个独立的比较函数，

Card这个类里面只有一个点数和一个花色，如果点数相同，花色肯定是不一样的，花色和点数咱前面定义到一个枚举类型里面了，

```cpp
bool lessSort(const Card &c1, const Card &c2) //c1<c2返回true
{
    if(c1.point() == c2.point())
    {
        return c1.suit() < c2.suit();
    }
    else
    {
        return c1.point() < c2.point();
    }
}

bool greaterSort(const Card &c1, const Card &c2) //c1>c2返回true
{
    if(c1.point() == c2.point())
    {
        return c1.suit() > c2.suit();
    }
    else
    {
        return c1.point() > c2.point();
    }
}
```

**每次从集合中取出两个元素值，然后通过lessSort进行比较，返回true，比较小的就放在前面，**

```cpp
CardList Cards::toCardList(Cards::SortType type)
{
    CardList list;  //定义一个QVector<card>容器
    for(auto it = m_cards.begin(); it != m_cards.end(); ++it)
    {
        list << *it; //把扑克牌从Qset取出，并存入list
    }
    //排序类型判断  容器list里面的参数是什么类型，排序函数lessSort的参数就是什么类型
    if (type == Asc)
    {
        std::sort(list.begin(), list.end(), lessSort);
    }
    if (type == Desc)
    {
        std::sort(list.begin(), list.end(), greaterSort);
    }
    return list;
}
```

直接给CardList指定默认排序值，从右到左，从小到大排列，

```cpp
CardList toCardList(SortType type = Desc); //将QSet无序数列转换成有序数列并存储到CardList
```

到这里，多张卡牌类就写完了.

### bug
编译，这里有个bug,

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757077042159-85c2d116-3a71-4f7a-b1e2-70d78040a14c.png)

这里带const限定的变量不能给没有const变量的参数进行赋值（但是没有const的对象可以给有const限定的对象进行赋值）。

这里推荐给add函数加个const. （也可以删除重载中的const）

```cpp
    //添加扑克牌
    void add(const Card& card);
    void add(const Cards& cards);
```

D:\Qt\Qt5.14.2\5.14.2\mingw73_64\include\QtCore\qhashfunctions.h:118: error: no matching function for call to 'qHash(const Card&)'

     noexcept(noexcept(qHash(t)))

                       ~~~~~^~~

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757078207643-e82f8b90-908c-4798-898f-9fe0ef5d62ce.png)

`<font style="color:rgb(0, 0, 0);">QSet<T></font>`<font style="color:rgb(0, 0, 0);"> 是 Qt 提供的</font>**<font style="color:rgb(0, 0, 0);">高效无序集合容器</font>**<font style="color:rgb(0, 0, 0);">，基于 </font>`<font style="color:rgb(0, 0, 0);">QHash</font>`<font style="color:rgb(0, 0, 0);"> 实现，用于存储唯一值并提供快速的查找操作,</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757078358170-dcf91f1f-3ef9-41ac-94ad-ed49f720e4ce.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757078468139-f2468e04-4550-4ee0-9c15-3f478d43b368.png)

<font style="color:rgb(0, 0, 0);">如果要将自定义类型（</font>`<font style="color:rgb(0, 0, 0);">Card</font>`<font style="color:rgb(0, 0, 0);"> 类）用作 </font>`**<font style="color:rgb(0, 0, 0);">QSet<T></font>**`**<font style="color:rgb(0, 0, 0);"> 或 </font>**`**<font style="color:rgb(0, 0, 0);">QHash</font>**`**<font style="color:rgb(0, 0, 0);"> 的键（Key）</font>**<font style="color:rgb(0, 0, 0);">，必须完成以下两步关键操作：</font>

+ **<font style="color:rgb(0, 0, 0);">默认情况下，</font>**`**<font style="color:rgb(0, 0, 0);">QSet<T></font>**`**<font style="color:rgb(0, 0, 0);"> </font>****<font style="color:rgb(0, 0, 0);">会尝试使用</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">operator==</font>**`**<font style="color:rgb(0, 0, 0);"> </font>****<font style="color:rgb(0, 0, 0);">和</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">qHash</font>**`**<font style="color:rgb(0, 0, 0);"> </font>****<font style="color:rgb(0, 0, 0);">进行元素比较和哈希计算。</font>**
+ **<font style="color:rgb(0, 0, 0);">如果</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">operator==</font>**`**<font style="color:rgb(0, 0, 0);"> </font>****<font style="color:rgb(0, 0, 0);">和</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">qHash</font>**`**<font style="color:rgb(0, 0, 0);"> </font>****<font style="color:rgb(0, 0, 0);">都没有定义，会发生编译错误，除非：</font>**
    - `<font style="color:rgb(0, 0, 0);">T</font>`<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">是</font><font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">基本类型（如</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">int</font>**`**<font style="color:rgb(0, 0, 0);">、</font>**`**<font style="color:rgb(0, 0, 0);">QString</font>**`**<font style="color:rgb(0, 0, 0);">）</font>**<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">→ Qt 已内置支持。</font>
    - `<font style="color:rgb(0, 0, 0);">T</font>`<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">是</font><font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">标准库类型（如</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">std::string</font>**`**<font style="color:rgb(0, 0, 0);">）</font>**<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">→ 可能报错（除非显式提供</font><font style="color:rgb(0, 0, 0);"> </font>`<font style="color:rgb(0, 0, 0);">qHash</font>`<font style="color:rgb(0, 0, 0);">）。</font>
    - `<font style="color:rgb(0, 0, 0);">T</font>`<font style="color:rgb(0, 0, 0);"> 是一个 </font>**<font style="color:rgb(0, 0, 0);">自定义类（如 </font>**`**<font style="color:rgb(0, 0, 0);">Card</font>**`**<font style="color:rgb(0, 0, 0);">）</font>**<font style="color:rgb(0, 0, 0);"> → </font>**<font style="color:rgb(0, 0, 0);">必须手动实现 </font>**`**<font style="color:rgb(0, 0, 0);">operator==</font>**`**<font style="color:rgb(0, 0, 0);"> 和 </font>**`**<font style="color:rgb(0, 0, 0);">qHash</font>**`<font style="color:rgb(0, 0, 0);">。</font>

#### <font style="color:rgb(0, 0, 0);">1. </font>**<font style="color:rgb(0, 0, 0);">重载 </font>**`**<font style="color:rgb(0, 0, 0);">operator==</font>**`
`<font style="color:rgb(0, 0, 0);">QSet</font>`<font style="color:rgb(0, 0, 0);"> 在插入、查找、去重时，必须判断两张牌是否相同，这就需要 </font>`<font style="color:rgb(0, 0, 0);">operator==</font>`<font style="color:rgb(0, 0, 0);"> 来定义“如何比较两张 </font>`<font style="color:rgb(0, 0, 0);">Card</font>`<font style="color:rgb(0, 0, 0);">”。</font>

```plain
QSet 内部会调用 `operator==` 判断是否相同
如果 `operator==` 返回 true，就不会重复插入
```

**<font style="color:rgb(0, 0, 0);">如果没有 </font>**`**<font style="color:rgb(0, 0, 0);">operator==</font>**`<font style="color:rgb(0, 0, 0);">：</font>

+ `<font style="color:rgb(0, 0, 0);">QSet</font>`<font style="color:rgb(0, 0, 0);"> 不知道两张 </font>`<font style="color:rgb(0, 0, 0);">Card</font>`<font style="color:rgb(0, 0, 0);"> 是否相同，可能导致</font>**<font style="color:rgb(0, 0, 0);">重复存储相同牌</font>**<font style="color:rgb(0, 0, 0);">或</font>**<font style="color:rgb(0, 0, 0);">查找失败</font>**<font style="color:rgb(0, 0, 0);">。</font>

#### <font style="color:rgb(0, 0, 0);">2.</font><font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">重写全局函数</font>****<font style="color:rgb(0, 0, 0);"> </font>**`**<font style="color:rgb(0, 0, 0);">qHash()</font>**`
`<font style="color:rgb(0, 0, 0);">QSet</font>`<font style="color:rgb(0, 0, 0);"> 内部使用哈希表存储数据，需通过 </font>`<font style="color:rgb(0, 0, 0);">qHash()</font>`<font style="color:rgb(0, 0, 0);"> 计算元素的哈希值以快速定位。</font>`<font style="color:rgb(0, 0, 0);">qHash</font>`<font style="color:rgb(0, 0, 0);"> 的作用是</font>**<font style="color:rgb(0, 0, 0);">计算每张牌的哈希值</font>**<font style="color:rgb(0, 0, 0);">，让查找、插入速度接近 </font>**<font style="color:rgb(0, 0, 0);">O(1)</font>**<font style="color:rgb(0, 0, 0);">（即超快）。</font>

**<font style="color:rgb(0, 0, 0);">如果没有 </font>**`**<font style="color:rgb(0, 0, 0);">qHash</font>**`<font style="color:rgb(0, 0, 0);">：</font>

+ `<font style="color:rgb(0, 0, 0);">QSet</font>`<font style="color:rgb(0, 0, 0);"> 会退化成 </font>**<font style="color:rgb(0, 0, 0);">List</font>**<font style="color:rgb(0, 0, 0);">（或 </font>`<font style="color:rgb(0, 0, 0);">QList</font>`<font style="color:rgb(0, 0, 0);">），查找速度从 </font>**<font style="color:rgb(0, 0, 0);">O(1)</font>**<font style="color:rgb(0, 0, 0);"> 退化为 </font>**<font style="color:rgb(0, 0, 0);">O(n)</font>**<font style="color:rgb(0, 0, 0);">（即遍历所有牌找匹配的）。</font>

---

```plain
//操作符重载 (==)
bool operator == (const Card& left, const Card& right);
//重写全局函数 qHash 返回uint类型
uint qHash(const Card& card);
```

```plain
bool operator ==(const Card &left, const Card &right)
{
    //QSet 内部会调用 `operator==` 判断是否相同，点色和花色都相等就返回true
    return (left.point() == right.point() && left.suit() == right.suit());
}

uint qHash(const Card &card)
{
    //52张扑克牌的哈希值是52个,应该避免哈希冲突风险
    //因此把每张扑克牌对应的哈希值算成不同的数就行了
    return card.point() * 200 + card.suit();
}

```

---

再次编译，成功！

## 六、游戏玩家类
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757081356911-b918f844-5ef3-4c50-be36-0b4a95d69401.png)



对于游戏中的玩家分为两种，一种是机器人类robot，一种是用户玩家类UserPlayer，给这两个类添加一个共同的基类Player，用来定义相同的功能。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757081133925-114b5d08-450d-4d19-8db1-074286c91769.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757081176877-cae57da9-b6e1-416e-9bda-7b9b05653b2a.png)

对于一个基本玩家来说，需要具备的属性，如图所示，

对于玩家的基类Player，已经构建好了，下面我们再添加一个玩家的属性，属性如名字可以添加到构造函数中，

```plain
#ifndef PLAYER_H
#define PLAYER_H

#include <QObject>

class Player : public QObject
{
    Q_OBJECT
public:
    explicit Player(QObject *parent = nullptr);
    explicit Player(QString name, QObject *parent = nullptr);  //添加构造函数 包含玩家属性

signals:

private:
    QString m_name; //玩家姓名

};

#endif // PLAYER_H
```

下面来实现一下构造函数，只需要把名字保存下来即可，

```plain
Player::Player(QString name, QObject *parent)
{
    m_name = name;
}
```

下面继续完善玩家的属性，

首先定义一个枚举来保存角色属性，包含地主和农民，

```plain
enum Role{Lord, Farmer}; //角色
```

然后是玩家的性别，

```plain
enum Sex{Man, Woman};  //性别
```

游戏里面人物头像显示方向，比如左边玩家头像需要朝向右，右边玩家头像需要朝向左，

```plain
enum Direction{Left, Right};  //头像的显示方位
```

是玩家的类型，包含机器人玩家和用户玩家，

```plain
enum Type{Robot, User, UnKnow}; //玩家的类型
```

我们还需要在当前类添加相关的操作函数，比如设置角色属性，设置性别，设置头像的方位以及玩家的类型等，

另外，设置函数，一般对应一个get获取函数，

```plain
public:
    enum Role{Lord, Farmer}; //角色
    enum Sex{Man, Woman};    //性别
    enum Direction{Left, Right};    //头像的显示方位
    enum Type{Robot, User, UnKnow}; //玩家的类型

    explicit Player(QObject *parent = nullptr);
    explicit Player(QString name, QObject *parent = nullptr);  //添加构造函数 包含玩家属性

    //名字
    void setName(QString name);
    QString getName();
    //角色
    void setRole(Role role);  //枚举类型参数
    Role getRole();
    //性别
    void setSex(Sex sex);
    Sex getSex();
    //方位
    void setDirection(Direction direction);
    Direction getDirection();
    //玩家类型
    void setType(Type type);
    Type getType();

    //玩家得分
    void setScore(int score);
    int getScore();
    //游戏结果
    void setWin(bool flag);
    bool isWin();

private:
    QString m_name; //玩家姓名
    Role m_role; //玩家角色
    Sex m_sex;   //玩家性别
    Direction m_direcrion; //玩家方位
    Type m_type; //玩家类型

    int m_score;  //玩家得分
    bool m_isWin; //玩家是否赢了
```

```plain
Player::Player(QString name, QObject *parent)
{
    m_name = name;
}

void Player::setName(QString name)
{
    m_name = name;
}

QString Player::getName()
{
    return m_name;
}

void Player::setRole(Player::Role role)
{
    m_role = role;
}

Player::Role Player::getRole()
{
    return m_role;
}

void Player::setSex(Player::Sex sex)
{
    m_sex = sex;
}

Player::Sex Player::getSex()
{
    return m_sex;
}

void Player::setDirection(Player::Direction direction)
{
    m_direcrion = direction;
}

Player::Direction Player::getDirection()
{
    return m_direcrion;
}

void Player::setType(Player::Type type)
{
    m_type = type;
}

Player::Type Player::getType()
{
    return m_type;
}

void Player::setScore(int score)
{
    m_score = score;
}

int Player::getScore()
{
    return m_score;
}

void Player::setWin(bool flag)
{
    m_isWin = flag;
}

bool Player::isWin()
{
    return m_isWin;
}
```

三个玩家轮流出牌，因此需要知道玩家上家是是谁，下家是谁？

因此需要提供两个指针来保存玩家上家和下家的地址，

```plain
public:
    //提供当前对象的上家和下家
    void setPrevPlayer(Player* player);
    void setNextPlayer(Player* player);
    Player* getPrevPlayer();
    Player* getNextPlayer();
private:
    Player* m_prev; //上家
    Player* m_next; //下家
```

```plain
void Player::setPrevPlayer(Player *player)
{
    m_prev = player;
}

void Player::setNextPlayer(Player *player)
{
    m_next = player;
}

Player *Player::getPrevPlayer()
{
    return m_prev;
}

Player *Player::getNextPlayer()
{
    return m_next;
}
```

发完牌之后需要进行下注，叫地主或者抢地主，

```plain
//叫地主？抢地主 下注0,1,2,3分，0分就是不抢地主
void grabLordBet(int point);
```

目前还没有处理游戏的操作流程，因此先空着这个函数。

发牌的时候，依次从中间向三位玩家进行发牌，玩家收到牌之后需要存储起来，因此需要一个对象进行卡牌的存储，因此需要引入Cards类，

```plain
#include "cards.h" //多张卡牌类

Cards m_cards; //存储多张扑克牌（玩家手中的牌）
```

首先是发牌时，每个玩家每次存储一张扑克牌，

```plain
//存储扑克牌（发牌时得到的扑克牌）
void storeDispatchCard(Card& card);
```

然后是需要保留三张底盘，给抢到地主的玩家，这三种扑克牌是一次性发出，因此需要存储一次多张扑克牌，

```plain
void storeDispatchCard(Cards& cards);
```

```plain
void Player::storeDispatchCard(Card &card)
{
    m_cards.add(card);
}

void Player::storeDispatchCard(Cards &cards)
{
    m_cards.add(cards);
}
```

另外需要将玩家存储的扑克牌展示在窗口中，因此需要知道有多少字扑克牌，并且知道每张扑克牌的点数花色，

```plain
    //得到多张扑克牌
    Cards getCards();
    //清空多张扑克牌
    void clearCards();
```

```plain
void Player::storeDispatchCard(Card &card)
{
    m_cards.add(card);
}

void Player::storeDispatchCard(Cards &cards)
{
    m_cards.add(cards);
}

Cards Player::getCards()
{
    return m_cards;
}

void Player::clearCards()
{
    m_cards.clear();
}
```

然后是出牌，可能出一张票也可能出多张牌，

```plain
    //出牌
    void playHand(Cards& cards);
```

```plain
void Player::playHand(Cards &cards)
{
    m_cards.remove(cards); //打出扑克牌就从手中删掉
}
```

另外用户出牌之后，如果没人要就可以继续出牌，如果下家比较大就可以出牌，因此需要保存打出的扑克牌并与下家可能要打出的扑克牌进行比较，

```plain
public:
  //设置出牌的玩家已经待处理的扑克牌
  void setPendingInfo(Player* player, Cards& cards);
  Player* getPendPlayer();
  Cards getPendCards();

private:
  Cards m_pendCards;    //保存打出的待处理的扑克牌
  Player* m_pendPlayer; //打出这张扑克牌的所有者
```

```plain
void Player::setPendingInfo(Player *player, Cards &cards)
{
    m_pendPlayer = player;
    m_pendCards = cards;
}

Player *Player::getPendPlayer()
{
    return m_pendPlayer;
}

Cards Player::getPendCards()
{
    return m_pendCards;
}
```

至此，玩家的基类的基本功能已经初步完成了。

---

还有两个玩家子类，一个是机器人类，一个是用户玩家类，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757335473274-a4e66e83-d8b9-4015-a9cd-45e165e39966.png)

两个用户都需要进行叫地主/抢地主/出牌，但是用户玩家是通过操作界面完成这些动作的，而机器人玩家是通过子线程自主处理完成相关动作的，这两个玩家在游戏过程中可以有同名的操作函数，但是内部处理的逻辑是不一样的，因此，可以使用**多态**来实现。

首先在player类里面添加两个**虚函数**，一个准备叫地主，一个准备出牌，

```plain
//虚函数
virtual void prepareCallLord();
virtual void preparePlayerHand();
```

对于这两个操作，对于用户玩家来说，需要进行思考之后进行动作，对于机器人玩家来说，直接在虚函数里面写出来就行了，

```plain
void Player::prepareCallLord()
{
    
}

void Player::preparePlayerHand()
{
    
}
```

函数体内部可以空着，也可以让虚函数等于0，但是如果让着两个虚函数等于0的话，就是纯虚函数了，变成纯虚函数后，这个player基类就变成一个抽象类了，抽象类是不能进行实例化的。

接下来咱们再来添加两个玩家类的子类。

## 七、玩家子类-机器人玩家
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757336843478-a493fefe-3b81-4bb6-a5c0-3b196de6738f.png)

```plain
#ifndef ROBOT_H
#define ROBOT_H

#include <QObject>
#include "player.h" //基类

class Robot : public Player
{
    Q_OBJECT
public: 
    //Robot(); //Add New 新建可能默认是普通的默认构造函数,并且缺少基类头文件
    // 显式声明（explicit） 的构造函数，接受一个可选的 QObject* 父对象参数（默认值为 nullptr）
    explicit Robot(QObject *parent = nullptr);

};

#endif // ROBOT_H

```

```plain
    //重写基类虚函数
    void prepareCallLord() override;
    void preparePlayerHand() override;
```

加上override关键字，表示重写父类的虚函数，如果这个虚函数不是父类的虚函数就会编译器显示报错，

对于这两个虚函数的具体内容，在后续分析游戏的具体流程时再实现。

## 八、玩家子类-用户玩家
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757337877524-d907186f-c3fc-4195-927e-9b6ff7f69e61.png)

```plain
#ifndef USERPLAYER_H
#define USERPLAYER_H

#include <QObject>
#include "player.h"

class UserPlayer : public Player
{
    Q_OBJECT
public:
    //UserPlayer();
    explicit UserPlayer(QObject *parent = nullptr);

    void prepareCallLord() override;
    void preparePlayerHand() override;
};

#endif // USERPLAYER_H
```

通前面一样，把父类的两个虚函数重写一下。（也暂时空着）

---

## 基础构造函数
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757338166738-967c0897-f0bf-4220-94f7-e43653d5f840.png)

在玩家父类中，有两个构造函数，其中一个指定了玩家的名字，我们也需要在子类中继续指定玩家的名字，有两种方法，一种方法是在子类里继续添加一个构造函数，给构造函数加上名字参数，另外一种方法是使用**继承构造函数**，就是直接继承父类的构造函数就行了，我们就不需要在子类里面再写一遍了，

```plain
using Player::Player; //告诉当前的类可以使用基类中的所有构造函数
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757338605638-7b75baa0-94ec-485e-a482-0981d4b26e8a.png)

另外对于基类中的成员变量，如果在子类中需要继承的话，就不能使用私有权限了，**需要改成protected**受保护的，改完了就可以在子类中随意使用这些变量了。

比如：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757339140563-d937504b-8a30-46b0-9102-594ab8edb755.png)

```plain
Robot::Robot(QObject *parent) : Player(parent)
{
    m_type = Player :: Robot;
}
```

```plain
UserPlayer::UserPlayer(QObject *parent) : Player(parent)
{
    m_type = Player :: User;
}
```

## 九、游戏控制类
让卡牌类和玩家类整体协调起来组成一个游戏！

需要定义一个游戏控制类对这些对象进行管理，由于后续需要用到信号槽机制，因此继承QObject基类，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757421430165-bf8138be-1211-406c-9ac5-c7936368782e.png)

首先是游戏状态和玩家状态，可以将其定义成枚举类型，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757421499789-c02c12f3-f4e6-43a7-adf2-af542808c595.png)

```plain
    //游戏状态
    enum GameStatus{
        DispatchCard, //发牌
        CallingLord,  //叫地主
        PlayingHand   //出牌
    };
    //玩家状态
    enum PlayerStatus{
        ThinkingForCallLord, //考虑叫地主
        ThinkingForPlayHand, //考虑出牌
        Winning              //获胜
    };
```

玩家的初始化，一个三个玩家，两个机器人和一个用户玩家，每个玩家需要对应一个实例对象，

机器人玩家对应的是Robot类型，用户玩家对应的是UserPlayer类型, 

```plain
#include "userplayer.h"
#include "robot.h"
```

添加三个私有成员变量，其中两个是Robot类型的指针，还有一个是UserPlayer类型的指针，用这个指针来保存对应的实例对象地址，

```plain
private:
    Robot* m_robotLeft;  //左侧机器人
    Robot* m_robotRight; //右侧机器人
    UserPlayer* m_user;  //用户玩家
```

下面来实现初始化玩家函数，

```plain
    //初始化玩家
    void playerInit();
```

在playerInit函数里面，需要对刚才创建的三个指针进行实例化，把它们对应的对象先new出来，

```plain
    //对象实例化
    m_robotLeft = new Robot("机器人A", this);
    m_robotRight = new Robot("机器人B", this);
    m_user = new UserPlayer("我自己", this);
```

第二个参数this，是给这个对象指定一个父对象，

父对象的作用就是在当前GameControl释放的时候自动的释放这三个对象，

对象实例化之后，接下来设置相关的属性信息，

```plain
    //头像的显示  不同子类调用相同基类的共有函数
    m_robotLeft->setDirection(Player::Left);
    m_robotRight->setDirection(Player::Right);
    m_user->setDirection(Player::Right);
```

```plain
    //性别  随机生成 #include <QRandomGenerator>
    Player::Sex sex;
    sex = (Player::Sex)QRandomGenerator::global()->bounded(2);  //0男-1女  数字强制转换成枚举类型对应的值
    m_robotLeft->setSex(sex);
    sex = (Player::Sex)QRandomGenerator::global()->bounded(2);  //0男-1女  数字强制转换成枚举类型对应的值
    m_robotRight->setSex(sex);
    sex = (Player::Sex)QRandomGenerator::global()->bounded(2);  //0男-1女  数字强制转换成枚举类型对应的值
    m_user->setSex(sex);
```

还有个属性是玩家的类别，关于玩家的类别，其实在创建类型对象的时候已经设置好了，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757426273574-4b1566f4-b812-47f2-a063-aa3a69a27194.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757426287311-07097e2b-81d0-4220-ba07-f90729cb5f42.png)

因此就不需要调用对应的set函数进行设定了。

除此之外，还有三个玩家的出牌顺序需要设定，

```plain
    // 出牌顺序
    //user
    m_user->setPrevPlayer(m_robotLeft);
    m_user->setNextPlayer(m_robotRight);

    //left robot
    m_robotLeft->setPrevPlayer(m_robotRight);
    m_robotLeft->setNextPlayer(m_user);

    //right robot
    m_robotRight->setPrevPlayer(m_user);
    m_robotRight->setNextPlayer(m_robotLeft);
```

这三个玩家出牌顺序指定之后，还需要知道当前玩家是谁？

在游戏开始之后，必须现有一个玩家叫地主，他叫完地主之后，再由他的下家叫地主，

谁是当前玩家，咱们需要再初始化的时候指定出来，因此咱需要先定义一个保存当前玩家对象的指针，

由于这个玩家类型可能是机器人Robot也可能是用户UserPlayer，因此指定其为父类Player类型,

```plain
Player* m_currPlayer; //当前出牌玩家
```

```plain
    // 指定当前玩家
    m_currPlayer = m_user;
```

游戏开始时，必须指定一个玩家叫地主，指定谁为当前玩家都是没关系的，这里先指定用户玩家为当前玩家，让其拥有优先叫地主的权利，下面需要得到玩家的实例化对象，

```plain
    //得到玩家的实例对象
    Robot* getLeftRobot();
    Robot* getRightRobot();
    UserPlayer* getUserPlayer();
```

```plain
Robot *GameControl::getLeftRobot()
{
    return m_robotLeft;
}

Robot *GameControl::getRightRobot()
{
    return m_robotRight;
}

UserPlayer *GameControl::getUserPlayer()
{
    return m_user;
}
```

```plain
    void setCurrentPlayer(Player* player);
    Player* getCurrentPlayer(); //当前玩家需要先设置再得到
```

```plain
void GameControl::setCurrentPlayer(Player *player)
{
    m_currPlayer = player;
}

Player *GameControl::getCurrentPlayer()
{
    return m_currPlayer;
}
```

关于出牌的对象，咱们要保存下来，只有保存了出牌对象之后，咱们在出牌的时候才能做出相关的判断。如果说这个牌不是我打出的，我就需要对打出的牌进行判断，我必须要打出比这个牌更大的点数才可以；如果这个牌在上一把就是我打出的，说明转了一圈之后没人能压住我的牌，所以我在下一轮就可以随意出牌。因此需要再定义两个函数，一个得到出牌玩家，一个得到出牌玩家打出的牌，

```plain
#include "cards.h"
```

```plain
    //得到出牌玩家和打出的牌
    Player* getPendPlayer();
    Cards getPendCards();
```

在当前类添加私有成员，

```plain
    Player* m_pendPlayer; //出牌的玩家
    Cards m_PendCards;  //打出的牌
```

关于这个m_PendCards什么时候初始化，当前不研究，因为这个类是个游戏管理类，后面肯定有出牌的动作，当我们调用了那个出牌函数之后，咱们就需要把玩家打出的那张牌，通过这个m_PendCards保存下来，然后调用getPendCards函数就能得到保存的这张扑克牌，同理，打出牌的这个玩家也需要一个指针来记录一下它对应的实例对象。

```plain
Player *GameControl::getPendPlayer()
{
    return m_pendPlayer;
}

Cards GameControl::getPendCards()
{
    return m_pendCards;
}
```

下面来看一下扑克牌·的·初始化操作，咱们初始化就是52张扑克牌的数据信息，在前面咱们已经写好了一个类Cards，在这个类里有个存储多张扑克牌的函数，初始化的过程中，需要把每张扑克牌的数据存储到卡牌对象里，

```plain
    //初始化扑克牌 洗牌
    void initAllCards();
```

```plain
    Cards m_allcards;   //所有卡牌
```

首先将Card对象，进行初始化，然后将其添加到多张卡牌类中去，

对于Card对象如何进行初始化，首先找一下Card类的构造函数<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757488889693-ec516165-0b78-4843-90f8-a6ca5b5c9c63.png)，

如果直接调用这个构造函数，咱们得到的是一个空对象，那么这个空对象里如何拥有数据呢？咱们就需要调用对应的set方法，另外也可以添加一个带参数的Card类构造函数，

```plain
Card(CardPoint point, CardSuit suit); //添加一个带参数的Card类构造函数

Card::Card(Card::CardPoint point, Card::CardSuit suit)
{
    setPoint(point);
    setSuit(suit);
}
```

```plain
void GameControl::initAllCards()
{
    m_allcards.clear();
    for (Card::CardPoint p = Card::Card_Begin+1; p < Card::Card_SJ; ++p ){
        for (Card::CardSuit s = Card::Suit_Begin+1; s < Card::Suit_End; ++s)
        {
            Card c(p, s);
            m_allcards.add(c);
        }
    }
    m_allcards.add(Card(Card::Card_SJ, Card::Suit_Begin));
    m_allcards.add(Card(Card::Card_BJ, Card::Suit_Begin));
}
```

#### 这里有bug，
1. `**<font style="color:rgb(0, 0, 0);">Card::CardPoint</font>**`<font style="color:rgb(0, 0, 0);"> 是一个 </font>**<font style="color:rgb(0, 0, 0);">枚举类型，</font>**`**<font style="color:rgb(0, 0, 0);">Card::Card_Begin + 1</font>**`<font style="color:rgb(0, 0, 0);"> 是一个 </font>`**<font style="color:rgb(0, 0, 0);">int</font>**`<font style="color:rgb(0, 0, 0);"> 运算， 因为</font>`**<font style="color:rgb(0, 0, 0);">enum</font>**`**<font style="color:rgb(0, 0, 0);"> 值可以隐式转 </font>**`**<font style="color:rgb(0, 0, 0);">int</font>**`**<font style="color:rgb(0, 0, 0);">，但反向（</font>**`**<font style="color:rgb(0, 0, 0);">int</font>**`**<font style="color:rgb(0, 0, 0);"> 转 </font>**`**<font style="color:rgb(0, 0, 0);">enum</font>**`**<font style="color:rgb(0, 0, 0);">）通常不允许</font>**<font style="color:rgb(0, 0, 0);">（除非显式转换）。</font>
2. <font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">C++11 的 </font>**`**<font style="color:rgb(0, 0, 0);">enum class</font>**`<font style="color:rgb(0, 0, 0);"> 中尤为严格，不允许隐式 </font>`<font style="color:rgb(0, 0, 0);">int</font>`<font style="color:rgb(0, 0, 0);"> → </font>`<font style="color:rgb(0, 0, 0);">enum</font>`<font style="color:rgb(0, 0, 0);"> 转换。</font>

```plain
    // enum 值可以隐式转 int,但反向不可以，可以使用static_cast<>进行显示转换
    for (Card::CardPoint p = static_cast<Card::CardPoint>(Card::Card_Begin + 1);
         p < Card::Card_SJ;
         p = static_cast<Card::CardPoint>(static_cast<int>(p) + 1))
    {

        for (Card::CardSuit s = static_cast<Card::CardSuit>(Card::Suit_Begin + 1);
             s < Card::Suit_End;
             s = static_cast<Card::CardSuit>(static_cast<int>(s) + 1))
        {
            Card c(p, s);
            m_allcards.add(c);
        }
    }
```

+ `<font style="color:rgb(0, 0, 0);">static_cast<Card::CardPoint></font>`<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">把</font><font style="color:rgb(0, 0, 0);"> </font>`<font style="color:rgb(0, 0, 0);">int</font>`<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">转</font><font style="color:rgb(0, 0, 0);"> </font>`<font style="color:rgb(0, 0, 0);">enum</font>`<font style="color:rgb(0, 0, 0);">。</font>
+ `<font style="color:rgb(0, 0, 0);">static_cast<int>(p) + 1</font>`<font style="color:rgb(0, 0, 0);"> 再转回 </font>`<font style="color:rgb(0, 0, 0);">int</font>`<font style="color:rgb(0, 0, 0);"> 运算（</font>`<font style="color:rgb(0, 0, 0);">++</font>`<font style="color:rgb(0, 0, 0);"> 可能无法直接作用于 </font>`<font style="color:rgb(0, 0, 0);">enum</font>`<font style="color:rgb(0, 0, 0);">）。</font>

```plain
    m_allcards.clear();
    for (int p = Card::Card_Begin+1; p < Card::Card_SJ; ++p ){
        for (int s = Card::Suit_Begin+1; s < Card::Suit_End; ++s)
        {
            //构造单张牌并添加到牌堆
            Card c((Card::CardPoint)p, (Card::CardSuit)s);  //强制转换int为Card卡牌类型
            //卡牌对象c: c.m_point = (CardPoint)p（点数） c.m_suit = (CardSuit)s（花色）
            m_allcards.add(c);
        }
    }
```

现在，所以的卡牌都存储到m_allcards这个对象了，下面实现每次发一张牌和得到最后一张牌，

```plain
    //每次发一张牌
    Card takeOneCard();
    //得到最后三张牌
    Cards getSurplusCards();
```

```plain
Card GameControl::takeOneCard()
{
     return m_allcards.takeRandCard(); //返回随机取一张牌
}

Cards GameControl::getSurplusCards()
{
    return m_allcards; //发牌到最后肯定只剩下三张，直接返回
}
```

清空玩家手中扑克牌并洗牌，

```plain
void GameControl::restCardData()
{
    //洗牌
    initAllCards();
    //清空扑克牌
    m_robotLeft->clearCards();
    m_robotRight->clearCards();
    m_user->clearCards();
    //初始化出牌玩家
    m_pendPlayer = nullptr;
    m_pendCards.clear();
}
```

然后是准备叫地主和成为地主并准备出牌，

```plain
    //开始叫地主
    void startCallLord();
    //成为地主
    void becomeLord(Player* player);
```

```plain
void GameControl::startCallLord()
{
    m_currPlayer->prepareCallLord(); //准备叫地主
}

void GameControl::becomeLord(Player *player)
{
    //三方角色
    m_currPlayer->setRole(Player::Lord);
    m_currPlayer->getPrevPlayer()->setRole(Player::Farmer);
    m_currPlayer->getNextPlayer()->setRole(Player::Farmer);
    //指定当前玩家 并每次存储三张底牌
    m_currPlayer = player;
    m_currPlayer->storeDispatchCard(m_allcards);  //m_cards.add(m_allcards);
    //准备出牌
    m_currPlayer->preparePlayerHand();
}
```

最后清空所有玩家得分。

```plain
    //清空所以玩家得分
    void clearScore();
```

```plain
void GameControl::clearScore()
{
    m_robotLeft->setScore(0);
    m_robotRight->setScore(0);
    m_user->setScore(0);
}
```

---

# 第二阶段：主界面功能开发
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757499104010-e35f8edd-df4c-4762-91a0-8261a9e68d3f.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757499075160-928ac2b0-56ae-4bfd-ae39-3c716b3587b2.png)

## 一、制作分数面板
新建QT界面，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757593465679-5f754e52-0ed8-4942-9e5c-aa6a939fbecc.png)

悬着widget类型窗口，这个类型窗口是可以内嵌的，可以没有边框的形式下完美的附着在父窗口上，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757593557300-df3ae7c1-a116-4ab8-bf30-7fb5483a9f32.png)

取名ScorePanel，完成。

---

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757593995122-6671ee67-4a0e-46a9-b7fa-b526fb43b4ef.png)

首先使用label标签，用来显示：玩家、得分、单位，然后点击最外侧界面进行栅格布局，并调节一下界面大小，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757594225380-b6f4cfc0-21e7-474e-a46d-9a5da91965d4.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757594323779-a2c307de-7610-4663-ab3f-87de1b566a9d.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757594475768-43d28fc1-bca7-4041-8991-f90252265152.png)

修改一下中间三个得分显示label的objectname名称，以及所有控件的字体，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757594850617-0f6c039f-5c9a-44a0-98f9-a213970e1a93.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757594936698-08911078-e10f-4494-b4cb-7f4104ab9a2d.png)

还可以添加字体颜色，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757595037929-c7eedce0-8cee-45f3-80d2-a8a2bd664430.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757595051984-2163ee80-9f3a-476c-bed0-b781e947ffaa.png)

设置文本居中，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757595209569-44e01204-a03f-4f4c-99ab-7fb649da1aa1.png)

也可以直接调用SetFont进行设置字体相关参数，类似样式表直接调用SetStyleSheet函数，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757595381661-9e4891ff-e4b4-44b6-945a-6d6a794b4583.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757595338497-13bb2088-0c67-4543-8234-5c443e93053a.png)

这个得分子窗口设置好之后，我们需要把它放置到主窗口里面（主窗口右上角），

打开主窗口GamePanel，先放一个Widget，然后再Widget里面再放一个Widget，然后放一个弹簧，让弹簧和分数面板做一个水平布局，将分数面板顶到右，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757595857401-bb21d8b7-5ab3-4f2e-b120-073e132231fd.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757596191922-545e7212-310a-4d7e-ab02-cb7a54553d7d.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757596117055-e0e12fe0-efda-44b0-80cb-6368c226e476.png)

现在子窗口是一个QWidget类型，并不是我们的分数面板窗口，因此需要做**窗口的提升**，所谓的提升就是把父类变成子类，咱们可以看到ScorePanel类的基类是QWidget，因此咱们可以把一个基类QWidget的类型的面板控件提升为子类ScorePanel类型，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757596354225-4f8778f4-0584-4a99-908a-467e44c6301b.png)

右键控件，提升为ScorePanel类型，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757596594376-276915e2-a267-4345-a931-9d6ad87599aa.png)

点击添加，再点提示，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757596882174-cece8138-5315-4644-aa9e-584ca4a83039.png)<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597001261-e96873bb-fec9-4f75-b606-7a8ecae36a31.png)

可以看到QT中的标准控件变成了自定义的控件类型，再改一下窗口名称，便于区分，

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597107700-c5c78290-8eb5-42c9-bce4-eb87d82d97dd.png)对GamePanel窗口做垂直布局，

然后再拿根弹簧顶上去，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597248881-44c196d6-4786-45d5-91f2-38d7ac458521.png)

虽然当前分数面板窗口显示很小，但是当程序运行之后，会将子窗口分数面板全部展现在窗口里面。

## 二、自定义按钮类
QT默认的按钮不是很美观，因此自定义按钮与后面更改的背景更搭。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597487396-e4afe1d9-2a7f-41c9-b638-e4d508367554.png)

开始只有一个按钮，当点击按钮之后，会出现一组按钮，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597526796-94644e81-91e8-48c9-afa8-0d2fd8fce3e7.png)

然后点击按钮过程中按钮有图片状态变化（三种）：鼠标不按，鼠标放上悬停，鼠标按下。

直接从QPushButton进行派生，美化按钮，需要创建一个不带UI界面的按钮类，

首先创建一个C++类，让其基类先继承QWidget，当这个类创建好之后再将基类改为QPushButton，<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597840604-e7056390-46b0-45ac-a0bd-fd3a38af7c3e.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/39216292/1757597989247-1a31e679-4397-45e4-bc69-d61e5423b376.png)

```plain
#ifndef MYBUTTON_H
#define MYBUTTON_H

#include <QPushButton>

class MyButton : public QPushButton
{
    Q_OBJECT
public:
    explicit MyButton(QWidget *parent = nullptr);

signals:

};

#endif // MYBUTTON_H
```

```plain
#include "mybutton.h"

MyButton::MyButton(QWidget *parent) : QPushButton(parent)
{

}

```

然后重写鼠标事件函数，不清楚可以查看一下帮助文档，

```plain
protected:
    // 重写鼠标事件函数
    //鼠标按下
    void mousePressEvent(QMouseEvent *ev);
    //鼠标释放
    void mouseReleaseEvent(QMouseEvent *ev);
    //鼠标进入
    void enterEvent(QEvent* ev);
    //绘图
    void paintEvent(QPaintEvent* ev);
```

在处理鼠标状态的时候，都需要有一张对应的图片来回应，也就是说咱们需要在这个类里面再添加一个设置图片的函数，三个状态因此需要对应三张图片，

```plain
void setImage(QString normal, QString hover, QString pressed);
```

```plain
private:
    //三张图片的路径
    QString normal;
    QString hover;
    QString pressed;
```





















